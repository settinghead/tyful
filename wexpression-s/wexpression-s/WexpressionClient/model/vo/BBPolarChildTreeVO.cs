// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 3/28/12 3:01 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Runtime.CompilerServices;
namespace Com.Settinghead.Wexpression.Client.Model.Vo
{
    public class BBPolarChildTreeVO : BBPolarTreeVO
    {

        private BBPolarRootTreeVO root;

        public BBPolarChildTreeVO(double r1, double r2, double d1, double d2, BBPolarRootTreeVO root_0, int minBoxSize)
        {
            super(r1, r2, d1, d2, minBoxSize);
            this.root = root_0;
        }


        public override int GetRootX()
        {
            return root.GetRootX();
        }


        public override int GetRootY()
        {
            return root.GetRootY();
        }


        protected internal override double ComputeX(bool rotate)
        {
            double x;
            if (GetR1(rotate) < HALF_PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    x = d2 * System.Math.Cos(PI);
                }
                else if (GetR2(rotate) < HALF_PI)
                {
                    x = d1 * System.Math.Cos(GetR2(rotate));
                }
                else if (GetR2(rotate) < PI)
                {
                    x = d2 * System.Math.Cos(GetR2(rotate));
                }
                else
                {
                    // circle
                    x = d2 * System.Math.Cos(PI);
                }
            }
            else if (GetR1(rotate) < PI)
            {
                if (GetR2(rotate) < HALF_PI)
                {
                    x = d2 * System.Math.Cos(PI);
                }
                else if (GetR2(rotate) < PI)
                {
                    x = d2 * System.Math.Cos(GetR2(rotate));
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    x = d2 * System.Math.Cos(PI);
                }
                else
                {
                    x = d2 * System.Math.Cos(PI);
                }
            }
            else if (GetR1(rotate) < ONE_AND_HALF_PI)
            {
                if (GetR2(rotate) < HALF_PI)
                {
                    x = d2 * System.Math.Cos(GetR1(rotate));
                }
                else if (GetR2(rotate) < GetR1(rotate))
                {
                    double x1 = d2 * System.Math.Cos(GetR1(rotate));
                    double x2 = d2 * System.Math.Cos(GetR2(rotate));
                    x = (x1 < x2) ? x1 : x2;
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    x = d2 * System.Math.Cos(GetR1(rotate));
                }
                else
                {
                    x = d2 * System.Math.Cos(GetR1(rotate));
                }
            }
            else
            {
                if (GetR2(rotate) < HALF_PI)
                {
                    double xx1 = d1 * System.Math.Cos(GetR1(rotate));
                    double xx2 = d1 * System.Math.Cos(GetR2(rotate));
                    x = (xx1 < xx2) ? xx1 : xx2;
                }
                else if (GetR2(rotate) < PI)
                {
                    x = d2 * System.Math.Cos(GetR2(rotate));
                }
                else if (GetR2(rotate) < GetR1(rotate))
                {
                    x = d2 * System.Math.Cos(PI);
                }
                else
                    x = d1 * System.Math.Cos(GetR1(rotate));
            }
            return x;
        }


        protected internal override double ComputeY(bool rotate)
        {
            double y;
            if (GetR1(rotate) < HALF_PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    y = d1 * System.Math.Sin(HALF_PI);
                }
                else if (GetR2(rotate) < HALF_PI)
                {
                    y = d2 * System.Math.Sin(GetR2(rotate));
                }
                else if (GetR2(rotate) < PI)
                {
                    y = d2 * System.Math.Sin(HALF_PI);
                }
                else
                {
                    // circle
                    y = d2 * System.Math.Sin(HALF_PI);
                }
            }
            else if (GetR1(rotate) < PI)
            {
                if (GetR2(rotate) < HALF_PI)
                {
                    double y1 = d2 * System.Math.Sin(GetR1(rotate));
                    double y2 = d2 * System.Math.Sin(GetR2(rotate));
                    y = (y1 > y2) ? y1 : y2;
                }
                else if (GetR2(rotate) < GetR1(rotate))
                    y = d2 * System.Math.Sin(HALF_PI);
                else
                    y = d2 * System.Math.Sin(GetR1(rotate));
            }
            else if (GetR1(rotate) < ONE_AND_HALF_PI)
            {
                if (GetR2(rotate) < PI)
                {
                    y = d2 * System.Math.Sin(HALF_PI);
                }
                else if (GetR2(rotate) < GetR1(rotate))
                {
                    y = d1 * System.Math.Sin(GetR2(rotate));
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    y = d1 * System.Math.Sin(GetR1(rotate));
                }
                else
                {
                    double val1 = d1 * System.Math.Sin(GetR2(rotate));
                    double val2 = d1 * System.Math.Sin(GetR1(rotate));
                    y = (val1 > val2) ? val1 : val2;
                }

            }
            else
            {
                if (GetR2(rotate) < HALF_PI)
                {
                    y = d2 * System.Math.Sin(GetR2(rotate));
                }
                else if (GetR2(rotate) < GetR1(rotate))
                {
                    y = d2 * System.Math.Sin(HALF_PI);
                }
                else
                    y = d1 * System.Math.Sin(GetR2(rotate));
            }
            y = -y;
            return y;
        }


        protected internal override double ComputeRight(bool rotate)
        {
            double right;
            if (GetR1(rotate) < HALF_PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    right = d2 * System.Math.Cos(0);
                }
                else if (GetR2(rotate) < HALF_PI)
                {
                    right = d2 * System.Math.Cos(GetR1(rotate));
                }
                else if (GetR2(rotate) < PI)
                {
                    right = d2 * System.Math.Cos(GetR1(rotate));
                }
                else
                {
                    // circle
                    right = d2 * System.Math.Cos(0);
                }
            }
            else if (GetR1(rotate) < PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    right = d2 * System.Math.Cos(0);
                }
                else if (GetR2(rotate) < PI)
                {
                    right = d1 * System.Math.Cos(GetR1(rotate));
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    double val1 = d1 * System.Math.Cos(GetR1(rotate));
                    ;
                    double val2 = d1 * System.Math.Cos(GetR2(rotate));
                    ;
                    right = (val1 > val2) ? val1 : val2;
                }
                else
                {
                    right = d2 * System.Math.Cos(GetR2(rotate));
                }
            }
            else if (GetR1(rotate) < ONE_AND_HALF_PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    right = d2 * System.Math.Cos(0);
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    right = d1 * System.Math.Cos(GetR2(rotate));
                }
                else
                {
                    right = d2 * System.Math.Cos(GetR2(rotate));
                }

            }
            else
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    right = d2 * System.Math.Cos(0);
                }
                else
                    right = d2 * System.Math.Cos(GetR2(rotate));
            }

            return right;

        }


        protected internal override double ComputeBottom(bool rotate)
        {
            double bottom;
            if (GetR1(rotate) < HALF_PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    bottom = d1 * System.Math.Sin(ONE_AND_HALF_PI);
                }
                else if (GetR2(rotate) < HALF_PI)
                {
                    bottom = d1 * System.Math.Sin(GetR1(rotate));
                }
                else if (GetR2(rotate) < PI)
                {
                    double val1 = d1 * System.Math.Sin(GetR1(rotate));
                    double val2 = d1 * System.Math.Sin(GetR2(rotate));
                    bottom = (val1 < val2) ? val1 : val2;
                }
                else
                {
                    // circle
                    bottom = d2 * System.Math.Sin(ONE_AND_HALF_PI);
                }
            }
            else if (GetR1(rotate) < PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    bottom = d1 * System.Math.Sin(ONE_AND_HALF_PI);
                }
                else if (GetR2(rotate) < PI)
                {
                    bottom = d1 * System.Math.Sin(GetR2(rotate));
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    bottom = d2 * System.Math.Sin(GetR2(rotate));
                }
                else
                {
                    bottom = d2 * System.Math.Sin(ONE_AND_HALF_PI);
                }
            }
            else if (GetR1(rotate) < ONE_AND_HALF_PI)
            {
                if (GetR2(rotate) < GetR1(rotate))
                {
                    bottom = d2 * System.Math.Sin(ONE_AND_HALF_PI);
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    bottom = d2 * System.Math.Sin(GetR2(rotate));
                }
                else
                {
                    bottom = d2 * System.Math.Sin(ONE_AND_HALF_PI);
                }

            }
            else
            {
                if (GetR2(rotate) < PI)
                {
                    bottom = d2 * System.Math.Sin(GetR1(rotate));
                }
                else if (GetR2(rotate) < ONE_AND_HALF_PI)
                {
                    double b1 = d2 * System.Math.Sin(GetR1(rotate));
                    double b2 = d2 * System.Math.Sin(GetR2(rotate));
                    bottom = (b1 < b2) ? b1 : b2;
                }
                else if (GetR2(rotate) < GetR1(rotate))
                {
                    bottom = System.Math.Cos(ONE_AND_HALF_PI);
                }
                else
                    bottom = d2 * System.Math.Sin(GetR1(rotate));
            }
            bottom = -bottom;
            return bottom;
        }


        public override double GetRotation()
        {
            return root.GetRotation();
        }


        public override double GetCurrentStamp()
        {
            return root.GetCurrentStamp();
        }

        public override BBPolarRootTreeVO GetRoot()
        {
            return root;
        }


        public override int GetMinBoxSize()
        {
            return root.GetMinBoxSize();
        }


        public override IImageShape GetShape()
        {
            return root.GetShape();
        }
    }

}
