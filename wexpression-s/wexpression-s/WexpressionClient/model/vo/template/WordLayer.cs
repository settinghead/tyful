// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 3/28/12 3:01 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
using Com.Settinghead.Wexpression.Client.Angler;
using Com.Settinghead.Wexpression.Client.Fonter;
using Com.Settinghead.Wexpression.Client.Model.Vo;
using Com.Settinghead.Wexpression.Client.Nudger;
using Com.Settinghead.Wexpression.Client.Colorer;
using Com.Settinghead.Wexpression.Client.Placer;
using Org.Peaceoutside.Utils;
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Runtime.CompilerServices;

namespace Com.Settinghead.Wexpression.Client.Model.Vo.Template
{
    public class WordLayer : Layer, IImageShape, IZippable
    {
        public WordLayer(String name, TemplateVO template)
        {
            super(name, template);
        }

        private Bitmap _img;
        private Bitmap _colorSheet;
        private BBPolarRootTreeVO _tree;
        private Rectangle _bounds = null;
        public static const double SAMPLE_DISTANCE = 100;
        private static const double MISS_PERCENTAGE_THRESHOLD = 0.1;
        private String _path;
        private WordColorer _colorer;
        private WordNudger _nudger;
        private WordAngler _angler;
        //		private Array hsbArray;
        // Applet applet = new Applet();
        // Frame frame = new Frame("Roseindia.net");

        private WordFonter _fonter = null;
        public WordFonter fonter
        {
            get
            {
                if (this._fonter == null)
                {
                    return this._template.fonter;
                }
                else return this._fonter;
            }
        }

        private WordPlacer _placer;
        public WordColorer colorer
        {
            get
            {
                if (this._colorer == null)
                {
                    return this._template.colorer;
                }
                else return this._colorer;
            }
        }


        public BitmapData thumbnail
        {
            get
            {
                if (this._thumbnail == null && this.img != null)
                    this._thumbnail = createThumbnail(this.img.bitmapData);
                return this._thumbnail;
            }
        }

        private static BitmapData createThumbnail(BitmapData bmp)
        {
            return resizeImage(bmp, 100, 100);
        }

        private static const double IDEAL_RESIZE_PERCENT = .5;
        public static BitmapData resizeImage(BitmapData source, uint width, uint height, bool constrainProportions = true)
        {
            double scaleX = width / source.width;
            double scaleY = height / source.height;
            if (constrainProportions)
            {
                if (scaleX > scaleY) scaleX = scaleY;
                else scaleY = scaleX;
            }

            BitmapData bitmapData = source;

            if (scaleX >= 1 && scaleY >= 1)
            {
                bitmapData = new BitmapData(Math.ceil(source.width * scaleX), Math.ceil(source.height * scaleY), true, 0);
                bitmapData.draw(source, new Matrix(scaleX, 0, 0, scaleY), null, null, null, true);
                return bitmapData;
            }

            // scale it by the IDEAL for best quality
            double nextScaleX = scaleX;
            double nextScaleY = scaleY;
            while (nextScaleX < 1) nextScaleX /= IDEAL_RESIZE_PERCENT;
            while (nextScaleY < 1) nextScaleY /= IDEAL_RESIZE_PERCENT;

            if (scaleX < IDEAL_RESIZE_PERCENT) nextScaleX *= IDEAL_RESIZE_PERCENT;
            if (scaleY < IDEAL_RESIZE_PERCENT) nextScaleY *= IDEAL_RESIZE_PERCENT;

            BitmapData temp = new BitmapData(bitmapData.width * nextScaleX, bitmapData.height * nextScaleY, true, 0);
            temp.draw(bitmapData, new Matrix(nextScaleX, 0, 0, nextScaleY), null, null, null, true);
            bitmapData = temp;

            nextScaleX *= IDEAL_RESIZE_PERCENT;
            nextScaleY *= IDEAL_RESIZE_PERCENT;

            while (nextScaleX >= scaleX || nextScaleY >= scaleY)
            {
                double actualScaleX = nextScaleX >= scaleX ? IDEAL_RESIZE_PERCENT : 1;
                double actualScaleY = nextScaleY >= scaleY ? IDEAL_RESIZE_PERCENT : 1;
                temp = new BitmapData(bitmapData.width * actualScaleX, bitmapData.height * actualScaleY, true, 0);
                temp.draw(bitmapData, new Matrix(actualScaleX, 0, 0, actualScaleY), null, null, null, true);
                bitmapData.dispose();
                nextScaleX *= IDEAL_RESIZE_PERCENT;
                nextScaleY *= IDEAL_RESIZE_PERCENT;
                bitmapData = temp;
            }

            return bitmapData;
        }




        public int GetHSB(int x, int y)
        {
            //			if(this.hsbArray[x]==null)
            //				this.hsbArray[x] = new Array(this._img.height);
            //			if(this.hsbArray[x][y]==null){
            //				uint rgbPixel = _img.bitmapData.getPixel32( x, y );
            //				uint alpha = rgbPixel>> 24 & 0xFF;
            //				if(alpha == 0) {
            //					hsbArray[x][y]  = NaN;
            //					return NaN;
            //				}
            //				else {
            //					int colour =  ColorMath.RGBtoHSB(rgbPixel);
            //					hsbArray[x][y] = colour;
            //					return colour;
            //				}
            //			}
            //			return this.hsbArray[x][y];

            uint rgbPixel = _img.bitmapData.getPixel32(x, y);
            uint alpha = rgbPixel >> 24 & 0xFF;
            if (alpha == 0)
            {
                return NaN;
            }
            else
            {
                int colour = ColorMath.RGBtoHSB(rgbPixel);
                return colour;
            }
        }

        public double GetBrightness(int x, int y)
        {
            int colour = getHSB(x, y);
            double b = (colour & 0xFF);
            b /= 255;
            return b;
        }

        public double GetHue(int x, int y)
        {
            int colour = getHSB(x, y);
            //			Assert.isTrue(!isNaN(colour.hue));
            double h = ((colour & 0x00FF0000) >> 16);
            h /= 255;
            return h;
        }

        public double height
        {
            get
            {
                return img.height;
            }
        }

        public double width
        {
            get
            {
                return img.width;
            }
        }

        public Rectangle GetBounds2D()
        {

            if (this._bounds == null)
            {
                double centerX = img.width / 2;
                double centerY = img.height / 2;
                double radius = Math.sqrt(Math.pow(centerX, 2)
                    + Math.pow(centerY, 2));
                int diameter = ((int)(radius * 2));

                this._bounds = new Rectangle(((int)(centerX - radius)),
                    ((int)(centerY - radius)), diameter, diameter);
            }
            return this._bounds;
        }

        public override bool Contains(double x, double y, double width, double height, double rotation, bool transformed)
        {
            if (_tree == null)
            {
                // sampling approach
                int numSamples = ((int)(width * height / SAMPLE_DISTANCE));
                //				var numSamples = 10;
                // TODO: devise better lower bound
                if (numSamples < 20)
                    numSamples = 20;
                int threshold = 1;
                int darkCount = 0;
                int i = 0;
                while (i < numSamples)
                {
                    int relativeX = ((int)(Math.random() * width));
                    int relativeY = ((int)(Math.random() * height));

                    //rotation
                    rotation = -rotation;

                    if (rotation != 0)
                    {

                        //					Alert.show(rotation.toString());
                        if (relativeX == 0) relativeX = 0.001d;
                        relativeX = (relativeX - width / 2);
                        relativeY = (relativeY - height / 2);

                        double r = Math.sqrt(Math.pow(relativeX, 2) + Math.pow(relativeY, 2));
                        double theta = Math.atan2(relativeY, relativeX);
                        theta += rotation;

                        relativeX = r * Math.cos(theta);
                        relativeY = r * Math.sin(theta);

                        //					relativeX = (relativeX * Math.cos(rotation))
                        //						- (relativeY * Math.sin(rotation));
                        //					relativeY = Math.sin(rotation) * relativeX
                        //						+ Math.cos(rotation ) * relativeY;

                        relativeX = (relativeX + width / 2);
                        relativeY = (relativeY + height / 2);
                    }
                    int sampleX = relativeX + x;
                    int sampleY = relativeY + y;

                    double brightness = getBrightness(sampleX, sampleY);
                    if ((isNaN(brightness) || brightness < 0.01d) && ++darkCount >= threshold)
                        //											if ((!containsPo((int)sampleX, sampleY, false)) && ++darkCount >= threshold)
                        return false;
                    i++;
                }

                return true;

            }
            else
            {
                return _tree.overlapsCoord(x, y, x + width, y + height);
            }
        }


        public override bool ContainsPoint(double x, double y, boolean transform)
        {
            //			if(x<0 || y<0 || x>width || y>height) return true;
            return img.hitTestPo((int)x, y, true);
        }

        public override bool Intersects(double x, double y, double width, double height, bool transformed)
        {
            if (_tree == null)
            {
                int threshold = 10;
                int darkCount = 0;
                int brightCount = 0;

                int numSamples = ((int)(width * height / SAMPLE_DISTANCE));
                // TODO: devise better lower bound
                if (numSamples < 10)
                    numSamples = 10;

                int i = 0;
                while (i < numSamples)
                {
                    int relativeX = ((int)(Math.random() * width));
                    int relativeY = ((int)(Math.random() * height));
                    int sampleX = ((int)(relativeX + x));
                    int sampleY = ((int)(relativeY + y));
                    if (isNaN(getBrightness(((int)(sampleX)), ((int)(sampleY)))))
                        //					if(!containsPo((int)sampleX, sampleY, false))
                        darkCount++;
                    else
                        brightCount++;
                    if (darkCount >= threshold && brightCount >= threshold)
                        return true;
                    i++;
                }

                return false;

            }
            else
            {
                return _tree.overlapsCoord(x, y, x + width, y + height);
            }
        }

        public void Translate(double tx, double ty)
        {
            Matrix mtx = img.transform.matrix;
            mtx.translate(tx, ty);
            img.transform.matrix = mtx;
        }

        public DisplayObject Shape
        {
            get
            {
                return img;
            }
        }

        public DisplayObject Object
        {
            get
            {
                return img;
            }
        }

        public Bitmap img
        {
            get
            {
                if (this._img == null)
                {
                    if (path != null)
                        this.loadLayerFromPNG();
                    else
                    {
                        this._img = new Bitmap(new BitmapData(this._template.width, this._template.height, true, 0));
                    }
                }
                return _img;
            }
            set
            {
                this._img = value;

            }
        }

        public Bitmap colorSheet
        {
            set
            {
                this._colorSheet = bmp;
            }
        }

        public Bitmap colorSheet
        {
            get
            {
                if (this._colorSheet == null)
                {
                    this._colorSheet = new Bitmap(new BitmapData(this._template.width, this._template.height, true, 0));
                }
                return _colorSheet;
            }
        }

        public string path
        {
            get
            {
                return this._path;
            }
            set
            {
                this._path = value;
            }
        }


        public WordNudger nudger
        {
            get
            {
                if (this._nudger == null)
                {
                    return _template.nudger;
                }
                else return this._nudger;
            }
        }

        public WordAngler angler
        {
            get
            {
                if (this._angler == null)
                {
                    this._angler = new ShapeConfinedAngler(this, new MostlyHorizAngler());
                }
                return this._angler;
            }
        }


        public void loadLayerFromPNG(Function callback = null)
        {
            Loader my_loader = new Loader();

            my_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onLoadComplete);
            if (callback != null)
                my_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, callback);

            my_loader.load(new URLRequest(this._path));
        }

        private void onLoadComplete(Event evt0)
        {
            this._img = new Bitmap(evt0.target.content.bitmapData);
            //			this.hsbArray = new Array(this._img.width);
            this._template.onLoadComplete(evt0);
        }

        public override void WriteNonJSONPropertiesToZip(IZipOutput output)
        {
            output.process(this._fonter, "fonter");
            output.process(this._colorer, "colorer");
            output.putBitmapDataToPNGFile("direction.png", this._img.bitmapData);
            output.putBitmapDataToPNGFile("color.png", this._colorSheet.bitmapData);
            //			output.process(this._nudger, "nudger");
            //			output.process(this._angler, "angler");
            //			output.process(this._placer, "placer");
        }

        public override void ReadNonJSONPropertiesFromZip(IZipInput input)
        {
            //TODO
        }

        public override void SaveProperties(Object dict)
        {
        }

    }
}
