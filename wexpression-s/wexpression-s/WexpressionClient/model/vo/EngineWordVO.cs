// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 3/28/12 3:01 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
using Com.Settinghead.Wexpression.Client;
using Com.Settinghead.Wexpression.Client.Angler;
using Com.Settinghead.Wexpression.Client.Density;
using Com.Settinghead.Wexpression.Client.Placer;
using Java.Awt;
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Runtime.CompilerServices;
namespace Com.Settinghead.Wexpression.Client.Model.Vo
{


    /*
     Copyright 2010 Daniel Bernier
	
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
	
     http://www.apache.org/licenses/LICENSE-2.0
	
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
     */



    public class EngineWordVO
    {

        public const int SKIP_REASON_NO_SPACE = 1;
        public const int SKIP_REASON_SHAPE_TOO_SMALL = 2;


        private WordVO _word;
        private int rank;

        private TextShapeVO _shape;
        public BBPolarRootTreeVO bbTree;
        private double presetAngle = NaN;
        private double renderedAngle;

        private int desiredLocationIndex;

        private ArrayList<PlaceInfo> _desiredLocations;
        private PlaceInfo currentLocation;
        private ArrayList<PlaceInfo> targetPlaceInfo;
        private Point renderedPlace;
        private int skippedBecause = -1;
        public Array samplePoints;


        public EngineWordVO(WordVO word, int rank_0, int wordCount)
        {
            this._word = word;
            this.rank = rank_0;
        }

        public void SetShape(TextShapeVO shape, int swelling)
        {
            this._shape = shape;
            this.bbTree = BBPolarTreeBuilder.MakeTree(shape, swelling);
            DrawSamples();
        }

        private void DrawSamples()
        {
            this.samplePoints = new Array();
            int numSamples = ((int)(shape.width * shape.height / WordLayer.SAMPLE_DISTANCE));
            //				var numSamples = 10;
            // TODO: devise better lower bound
            if (numSamples < 20)
                numSamples = 20;
            for (int i = 0; i < numSamples; i++)
            {
                double relativeX = ((int)(Math.random() * shape.width));
                double relativeY = ((int)(Math.random() * shape.height));
                if (shape.containsPo((int)relativeX, relativeY, false))
                {
                    relativeX -= shape.width / 2;
                    relativeY -= shape.height / 2;
                    double d = Math.sqrt(Math.pow(relativeX, 2) + Math.pow(relativeY, 2));
                    double r = Math.atan2(relativeY, relativeX);
                    samplePoints.push(new double[] { r, d });
                }
            }
        }

        public TextShapeVO shape
        {
            get
            {
                return _shape;
            }
        }

        public bool Overlaps(EngineWordVO other)
        {
            return bbTree.Overlaps(other.bbTree);
        }

        public void RetrieveDesiredLocations(WordPlacer placer, int count, int wordImageWidth, int wordImageHeight, int fieldWidth, int fieldHeight)
        {
            _desiredLocations = GetTargetPlace(placer, rank, count,
                    wordImageWidth, wordImageHeight, fieldWidth, fieldHeight);
        }

        public bool HasNextDesiredLocation()
        {
            return desiredLocationIndex < _desiredLocations.length;
        }

        public PlaceInfo NextDesiredLocation()
        {
            return _desiredLocations[desiredLocationIndex++];
        }

        public void NudgeTo(Point loc, Patch patch)
        {
            currentLocation = new PlaceInfo(loc, patch);
            bbTree.SetLocation(((int)currentLocation.GetpVector().x),
                    ((int)currentLocation.GetpVector().y));
        }

        public void FinalizeLocation()
        {

            double x = currentLocation.GetpVector().x;
            double y = currentLocation.GetpVector().y;
            shape.SetCenterLocation(x, y);

            _shape =
                // WordShaper.moveToOrigin(
            WordShaper.Rotate(shape, GetTree().GetRotation()
                    );

            bbTree.SetLocation(currentLocation.GetpVector().x, currentLocation.GetpVector().y);
            SetRenderedPlace(currentLocation.GetpVector());
            currentLocation.patch.eWords.Push(this);
        }

        public IList<PlaceInfo> desiredLocations
        {
            get
            {
                return this._desiredLocations;
            }
        }

        public double offsetDistance
        {
            get
            {
                double distSum = 0;
                for (int i = 0; i < desiredLocationIndex; i++)
                {
                    distSum += this.currentLocation.distanceFrom(this._desiredLocations[i]);
                }
                return distSum;
            }
        }

        public PlaceInfo CurrentLocation
        {
            get
            {
                if (currentLocation != null)
                    return currentLocation;
                else
                    return null;
            }
        }

        public bool Trespassed(Layer layer, double rotation)
        {
            if (layer == null) return false;
            double x = (this.currentLocation.GetpVector().x - this.shape.textField.width / 2);
            double y = (this.currentLocation.GetpVector().y - this.shape.textField.height / 2);

            // float right = (float) (this.currentLocation.getpVector().x + bounds
            // .getWidth());
            // float bottom = (float) (this.currentLocation.getpVector().y + bounds
            // .getHeight());
            //		Assert.isTrue( this.shape.textField.width>0);
            //		Assert.isTrue( this.shape.textField.height > 0);

            if (layer.ContainsAllPolarPoints(this.currentLocation.GetpVector().x,
                this.currentLocation.GetpVector().y, this.samplePoints, rotation))
            {
                return (layer.AboveContainsAllPolarPoints(this.currentLocation.GetpVector().x,
                    this.currentLocation.GetpVector().y, this.samplePoints, rotation));
            }

            if (layer.Contains(x, y, this.shape.textField.width, this.shape.textField.height, rotation, false))
            {
                return (layer.AboveContains(x, y, this.shape.textField.width, this.shape.textField.height, rotation, false));
            }
            else return true;
        }

        public BBPolarRootTreeVO GetTree()
        {
            return this.bbTree;
        }

        public double GetAngle(WordAngler angler)
        {
            renderedAngle = (!IsNaN(presetAngle)) ? presetAngle : angler
                    .AngleFor(this);
            return renderedAngle;
        }

        /// <summary>
        /// Set the angle this Word should be rendered at - WordCram won't even call
        /// the WordAngler.
        /// </summary>
        ///
        /// <returns>the Word, for more configuration</returns>
        public WordVO SetAngle(double angle)
        {
            this.presetAngle = angle;
            return this.word;
        }

        /// <summary>
        /// Get the angle the Word was rendered at: either the value passed to
        /// setAngle(), or the value returned from the WordAngler.
        /// </summary>
        ///
        /// <returns>the rendered angle</returns>
        public double GetRenderedAngle()
        {
            return renderedAngle;
        }


        public WordVO word
        {
            get
            {
                return this._word;
            }
        }


        public ArrayList<PlaceInfo> GetTargetPlace(WordPlacer placer, int rank_0, int count, int wordImageWidth, int wordImageHeight, int fieldWidth, int fieldHeight)
        {

            targetPlaceInfo = placer.place(this.word, rank_0, count, wordImageWidth,
                wordImageHeight, fieldWidth, fieldHeight);
            return targetPlaceInfo;
        }

        public void SetRenderedPlace(Point place)
        {
            renderedPlace = place.Clone();
        }

        /// <summary>
        /// Indicates whether the Word was placed successfully. It's the same as
        /// calling word.getRenderedPlace() != null. If this returns false, it's
        /// either because a) WordCram didn't get to this Word yet, or b) it was
        /// skipped for some reason (see <see cref="M:Com.Settinghead.Wexpression.Client.Model.Vo.EngineWordVO.WasSkipped"/> and<see cref="M:Com.Settinghead.Wexpression.Client.Model.Vo.EngineWordVO.WasSkippedBecause(System.Int32)"/>).
        /// </summary>
        ///
        /// <returns>true only if the word was placed.</returns>
        public bool WasPlaced()
        {
            return renderedPlace != null;
        }

        /// <summary>
        /// Indicates whether the Word was skipped.
        /// </summary>
        ///
        /// <seealso cref="null"/>
        /// <returns>true if the word was skipped</returns>
        public bool WasSkipped()
        {
            return this.GetWasSkippedBecause() >= 0;
        }

        /// <summary>
        /// Tells you why this Word was skipped.
        /// If the word was skipped, then this will return an Integer, which will be
        /// one of <see cref="null"/>,<see cref="null"/>, or <see cref="null"/>.
        /// If the word was successfully placed, or WordCram hasn't gotten to this
        /// word yet, this will return null.
        /// </summary>
        ///
        /// <returns>the code for the reason the word was skipped, or null if it
        /// wasn't skipped.</returns>
        public int GetWasSkippedBecause()
        {
            return skippedBecause;
        }

        public void WasSkippedBecause(int reason)
        {
            skippedBecause = reason;
        }



        public DisplayWordVO rendition(uint c)
        {

            DisplayWordVO s = new DisplayWordVO(this);

            this.shape.textField.textColor = c;
            s.AddChild(this.shape.textField);

            double w = s.width;
            double h = s.height;
            s.x = this.shape.centerX - w / 2;
            s.y = this.shape.centerY - h / 2;

            if (this.shape.rotation != 0)
            {
                double centerX = s.x + s.width / 2;
                double centerY = s.y + s.height / 2;

                //			Point point=new Po((int)shape.shape.x+shape.shape.width/2, shape.shape.y+shape.shape.height/2);
                Matrix m = s.transform.matrix;
                m.tx -= centerX;
                m.ty -= centerY;
                m.Rotate(-this.shape.rotation); // was a missing "=" here
                m.tx += centerX;
                m.ty += centerY;
                s.transform.matrix = m;
            }

            //			var r = Math.sqrt(Math.pow(s.width/2,2)+Math.pow(s.height/2,2));

            return s;
        }

    }

}
