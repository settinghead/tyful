// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 3/28/12 3:00 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
using Com.Settinghead.Wexpression.Client.Model.Vo.Template;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Runtime.CompilerServices;
namespace Com.Settinghead.Wexpression.Client.Density
{

    public class DensityPatchIndex
    {

        private TemplateVO img;
        private LeveledPatchMap _map;

        public const int NUMBER_OF_DIVISIONS = 2;
        public const double QUEUE_ALPHA_THRESHOLD = double.NegativeInfinity;
        public const double MARK_FILL_FACTOR = 1;
        public const int NUMBER_OF_ATTEMPTED_PATCHES = 4;
        private bool locked;

        public DensityPatchIndex(TemplateVO img_0)
        {
            this.locked = false;
            this.img = img_0;
            _map = new LeveledPatchMap(this);
        }



        public IList<Patch> FindPatchFor(int width, int height)
        {

            if (locked) throw new Exception("Concurrent access of density patch index not supported.");

            List<Patch> result = new List<Patch>();

            //			result.push( getBestPatchAtLevel(0));

            int level = findGranularityLevel(width, height);

            double area = width * height;
            for (int i = 0; i < NUMBER_OF_ATTEMPTED_PATCHES; i++)
            {
                Patch p = getBestPatchAtLevel(level);
                if (p != null) result.push(p);
            }
            Assert.isTrue(result.length > 0);
            return result;
        }

        private Patch GetBestPatchAtLevel(int level)
        {
            Patch result = _map.GetBestPatchAtLevel(level);
            //			if (result == null)
            //				return getBestPatchAtLevel(level - 1);
            //			else
            return result;
        }

        private int FindGranularityLevel(int width, int height)
        {
            int max = (width > height) ? width : height;
            max *= 2;
            int minContainerLength = (img.width > img.height) ? img
                .width : img.height;
            int squareWidth = minContainerLength;
            int level = 0;

            while (squareWidth > max)
            {
                squareWidth /= NUMBER_OF_DIVISIONS;
                level++;
            }

            level -= 1;
            if (level < 0) level = 0;
            return level;
        }

        //		public void unmark(Patch patch) {
        //			patch.unmark(patch);
        //		}
        //		
        public void Add(Patch patch)
        {
            _map.Add(patch);
        }

        public TemplateVO template
        {
            get
            {
                return this.img;
            }
        }

        public LeveledPatchMap map
        {
            get
            {
                return _map;
            }
        }

        public void Lock()
        {
            this.locked = true;
        }

        public void Unlock()
        {
            this.locked = false;
        }
    }
}
