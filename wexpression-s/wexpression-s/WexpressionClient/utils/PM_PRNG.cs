/*
 * Copyright (c) 2009 Michael Baczynski, http://www.polygonal.de
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 3/28/12 3:01 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Runtime.CompilerServices;
namespace De.Polygonal.Utils
{

    public class PM_PRNG
    {
        /// <summary>
        /// set seed with a 31 bit unsigned integer
        /// between 1 and 0X7FFFFFFE inclusive. don't use 0!
        /// </summary>
        ///
        public uint seed;

        public PM_PRNG()
        {
            seed = 1;
        }

        /// <summary>
        /// provides the next pseudorandom number
        /// as an unsigned integer (31 bits)
        /// </summary>
        ///
        public uint nextInt()
        {
            return Gen();
        }

        /// <summary>
        /// provides the next pseudorandom number
        /// as a float between nearly 0 and nearly 1.0.
        /// </summary>
        ///
        public double NextDouble()
        {
            return (Gen() / 2147483647);
        }

        /// <summary>
        /// provides the next pseudorandom number
        /// as an unsigned integer (31 bits) betweeen
        /// a given range.
        /// </summary>
        ///
        public uint nextIntRange(double min, double max)
        {
            min -= .4999d;
            max += .4999d;
            return Math.Round(min + ((max - min) * NextDouble()), MidpointRounding.AwayFromZero);
        }

        /// <summary>
        /// provides the next pseudorandom number
        /// as a float between a given range.
        /// </summary>
        ///
        public double NextDoubleRange(double min, double max)
        {
            return min + ((max - min) * NextDouble());
        }

        /// <summary>
        /// generator:
        /// new-value = (old-value/// 16807) mod (2^31 - 1)
        /// </summary>
        ///
        private uint gen()
        {
            //integer version 1, for max int 2^46 - 1 or larger.
            return seed = (seed * 16807) % 2147483647;

            /**
             * integer version 2, for max int 2^31 - 1 (slowest)
             */
            //int test = 16807 * (seed % 127773 >> 0) - 2836 * (seed / 127773 >> 0);
            //return seed = (test > 0 ? test : test + 2147483647);

            /// <summary>
            /// david g. carta's optimisation is 15% slower than integer version 1
            /// </summary>
            ///
            //uint hi = 16807 * (seed >> 16);
            //uint lo = 16807 * (seed & 0xFFFF) + ((hi & 0x7FFF) << 16) + (hi >> 15);
            //return seed = (lo > 0x7FFFFFFF ? lo - 0x7FFFFFFF : lo);
        }

        private bool haveNextNextGaussian;
        private double nextNextGaussian;

        public double NextGaussian()
        {
            // See Knuth, ACP, Section 3.4.1 Algorithm C.
            if (haveNextNextGaussian)
            {
                haveNextNextGaussian = false;
                return nextNextGaussian;
            }
            else
            {
                double v1, v2, s;
                do
                {
                    v1 = 2 * nextDouble() - 1; // between -1 and 1
                    v2 = 2 * nextDouble() - 1; // between -1 and 1
                    s = v1 * v1 + v2 * v2;
                } while (s >= 1 || s == 0);
                double multiplier = Math.sqrt(-2 * Math.log(s) / s);
                nextNextGaussian = v2 * multiplier;
                haveNextNextGaussian = true;
                return v1 * multiplier;
            }
        }
    }

}
