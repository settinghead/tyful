// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 3/28/12 3:00 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
using Com.Settinghead.Wexpression.Client.Model.Vo;
using Com.Settinghead.Wexpression.Client.Model.Vo.Template;
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Runtime.CompilerServices;
using System.Windows.Media.Imaging;
using System.Windows.Controls;
using System.Windows.Input;

namespace Com.Settinghead.Wexpression.Client.View.Components.Template.Canvas
{
    public class TextFlowCanvas : UserControl
    {

        public TextFlowCanvas()
            : base()
        {
            this.addEventListener(MouseEvent.MOUSE_DOWN, this_mouseDownHandler);
            this.addEventListener(MouseEvent.MOUSE_UP, this_mouseUpHandler);
            this.addEventListener(MouseEvent.MOUSE_MOVE, this_mouseMoveHandler);
            this.addEventListener(MouseEvent.MOUSE_OVER, this_mouseOverHandler);
            this.addEventListener(MouseEvent.MOUSE_OUT, this_mouseOutHandler);
            this.addEventListener(FocusEvent.FOCUS_OUT, this_focusOutHandler);
            this.addEventListener("creationComplete", this_creationCompleteHandler);
            this.autoDrawBackground = false;
        }

        private TemplateEditor _templateEditor;
        public TemplateEditor TemplateEditor
        {
            set
            {
                this._templateEditor = value;
                BindingUtils.bindProperty(this, "thickness", _templateEditor.thicknessPicker, "thickness");
                BindingUtils.bindProperty(this, "angle", _templateEditor.directionPicker, "angle");
                BindingUtils.bindProperty(this, "colorPattern", _templateEditor.colorPicker, "colorPattern");
                BindingUtils.bindProperty(this, "currentLayer", _templateEditor.layerButtons, "selectedItem");
            }
            get
            {
                return _templateEditor;
            }
        }

        private double oldMouseX, oldMouseY;
        private bool drawingState = false;
        private BitmapImage bmpDirection;
        private BitmapImage bmpElement;
        private BitmapImage bmpDirElement;
        private BitmapImage colorSheetElement;

        protected internal void this_mouseDownHandler(object sender, MouseEventArgs e)
        {
            if (isCurrentLayer)
            {
                this.drawingState = true;
                oldMouseX = this.mouseX;
                oldMouseY = this.mouseY;
            }
        }

        private WordLayer layer
        {
            get
            {
                return (WordLayer)data;
            }
        }

        protected internal void this_mouseUpHandler(object sender, MouseEventArgs e)
        {
            if (isCurrentLayer)
            {
                this.drawingState = false;
            }
        }

        protected internal void this_mouseOutHandler(object sender, MouseEventArgs e)
        {
            //			Mouse.show();
            //			this.drawingState = false;
        }

        protected internal void this_focusOutHandler(object sender, MouseEventArgs e)
        {
            Mouse.hide();
            this.drawingState = false;
        }



        protected internal void this_mouseOverHandler(object sender, MouseEventArgs e)
        {
            Mouse.hide();
        }

        private UserControl cursor;

        private double _angle;
        private double _thickness;
        private WriteableBitmap _colorPattern;
        [Bindable]
        public double Angle
        {
            get
            {
                return _angle;
            }
            set
            {
                this._angle = a;
                rebuildCursor();
            }
        }

        [Bindable]
        public double thickness
        {
            get
            {
                return _thickness;
            }
            set
            {
                this._thickness = t;
                rebuildCursor();
            }
        }

        [Bindable]
        public WriteableBitmap ColorPattern
        {
            get
            {
                return _colorPattern;
            }
            set
            {
                this._colorPattern = p;
                rebuildCursor();
            }
        }


        public Layer currentLayer
        {
            set
            {
                this._isCurrentLayer = (value == this.layer);
                this.mouseEnabled = _isCurrentLayer;
                if (_isCurrentLayer)
                {
                    this.alpha = 1;
                }
                else
                {
                    this.alpha = 0.5;
                    Mouse.hide();
                }
            }

        }

        private bool _isCurrentLayer;

        public bool isCurrentLayer
        {
            get
            {
                return _isCurrentLayer;
            }
        }

        private void RebuildCursor()
        {
            if (cursor != null)
            {
                BitmapAsset a = new SmallA();

                UserControl colorLayer = new UserControl();
                colorLayer.graphics.clear();
                colorLayer.x = 0;
                colorLayer.y = 0;
                colorLayer.width = thickness;
                colorLayer.height = thickness;
                colorLayer.graphics.lineBitmapStyle(colorPattern, null, true, true);
                colorLayer.graphics.beginBitmapFill(colorPattern, null, true, true);
                colorLayer.graphics.drawCircle(0, 0, thickness / 2);
                colorLayer.graphics.endFill();

                UserControl textLayer = new UserControl();
                textLayer.graphics.clear();
                Matrix m = a.transform.matrix;
                m.tx -= a.width / 2;
                m.ty -= a.height / 2;
                m.rotate(-angle);
                m.tx += a.width / 2;
                m.ty += a.height / 2;
                textLayer.width = thickness;
                textLayer.height = thickness;
                textLayer.x = 0;
                textLayer.y = 0;
                textLayer.graphics.lineBitmapStyle(a.WriteableBitmap, m, true, true);
                textLayer.graphics.beginBitmapFill(a.WriteableBitmap, m, true, true);
                textLayer.graphics.drawCircle(0, 0, thickness / 2);
                textLayer.graphics.endFill();

                cursor.width = colorLayer.width;
                cursor.height = colorLayer.height;
                cursor.addChild(colorLayer);
                cursor.addChild(textLayer);
            }
        }

        //[Embed("SmallA.png")]
        public static Type SmallA;
        protected internal void this_mouseMoveHandler(object sender, MouseEventArgs e)
        {
            if (this.mouseX > 0 && this.mouseX < this.width && this.mouseY > 0 && this.mouseY < this.height)
            {
                this.cursor.visible = true;
                cursor.x = this.mouseX;
                cursor.y = this.mouseY;
            }
            else
            {
                this.drawingState = false;
                this.cursor.visible = false;
                Mouse.show();
            }

            if (drawingState)
            {
                Shape shape = new Shape();
                Shape dirShape = new Shape();
                Shape colorShape = new Shape();
                uint dirColor = ColorMath.HSLToRGB(angle / BBPolarTreeVO.TWO_PI, 0.5d, 0.5d);
                shape.graphics.lineStyle(thickness, dirColor, 1);
                colorShape.graphics.lineStyle(thickness, 0, 1, true);
                dirShape.graphics.lineStyle(thickness, 0, 0.5d, true);
                colorShape.graphics.lineBitmapStyle(colorPattern, m, true, true);
                BitmapAsset a = new SmallA();
                Matrix m = a.transform.matrix;
                m.rotate(-angle);
                dirShape.graphics.lineBitmapStyle(a.WriteableBitmap, m, true, true);
                shape.graphics.moveTo(oldMouseX, oldMouseY);
                dirShape.graphics.moveTo(oldMouseX, oldMouseY);
                colorShape.graphics.moveTo(oldMouseX, oldMouseY);
                shape.graphics.lineTo(this.mouseX, this.mouseY);
                dirShape.graphics.lineTo(this.mouseX, this.mouseY);
                colorShape.graphics.lineTo(this.mouseX, this.mouseY);


                layer.img.WriteableBitmap.draw(shape);
                bmpDirection.WriteableBitmap.draw(dirShape);
                layer.colorSheet.WriteableBitmap.draw(colorShape);

                oldMouseX = this.mouseX;
                oldMouseY = this.mouseY;
            }
        }

        protected internal void this_creationCompleteHandler(object sender, EventArgs e)
        {
            populateLayer();
            initCursor();
            rebuildCursor();
        }

        private void InitCursor()
        {
            cursor = new UserControl();
            cursor.depth = 999;
            cursor.graphics.clear();

            cursor.blendMode = BlendMode.HARDLIGHT;
            this.addElement(cursor);
        }

        private void PopulateLayer()
        {
            if (this.layer != null)
            {

                for (int i = 0; i < this.numChildren; i++)
                    this.removeChildAt(0);
                if (((WordLayer)layer).img != null)
                {
                    layer.img = ((WordLayer)layer).img;
                }
                else
                {
                    layer.img = new Bitmap(new WriteableBitmap(layer.width, layer.height, true, 0xffffff));
                    layer.img.visible = false;
                }


                bmpDirection = new Bitmap(new WriteableBitmap(layer.width, layer.height, true, 0xffffff));
                bmpDirection.alpha = 0.8d;


                this.width = layer.width;
                this.height = layer.height;
                bmpDirection.x = layer.img.x = 0; bmpDirection.y = layer.img.y = 0;


                for (double w = 0; w < layer.img.width; w += a.width)
                {
                    for (double h = 0; h < layer.img.height; h += a.height)
                    {
                        BitmapAsset a = new SmallA();
                        Matrix m = new Matrix();

                        double angle = layer.getHue(w + a.width / 2, h + a.height / 2) * BBPolarTreeVO.TWO_PI;
                        m.tx -= a.width / 2;
                        m.ty -= a.height / 2;
                        m.rotate(-angle);
                        m.tx += a.width / 2;
                        m.ty += a.height / 2;
                        Shape dirShape = new Shape();
                        dirShape.graphics.lineStyle(1, 0, 0.3d, false);
                        dirShape.graphics.lineBitmapStyle(a.WriteableBitmap, m, true, true);
                        for (double ox = 0; ox < a.width; ox++)
                            for (double oy = 0; oy < a.height; oy++)
                            {
                                if (layer.getBrightness(ox + w, oy + h) > 0)
                                {
                                    dirShape.graphics.moveTo(ox, oy);
                                    dirShape.graphics.lineTo(ox, oy + 1);
                                }
                            }
                        m = new Matrix();
                        m.tx += w;
                        m.ty += h;
                        bmpDirection.WriteableBitmap.draw(dirShape, m);

                    }
                }

                bmpElement = new BitmapImage();
                bmpElement.source = layer.img;
                colorSheetElement = new BitmapImage();
                colorSheetElement.source = layer.colorSheet;
                bmpDirElement = new BitmapImage();
                bmpDirElement.source = bmpDirection;
                bmpDirElement.alpha = 0.5d;

                //				this.addElement(bmpElement);
                this.addElement(colorSheetElement);
                this.addElement(bmpDirElement);
                //this.patchLayer.patchQueue = template.patchIndex.map.getQueue(3);
            }
        }


    }
}
