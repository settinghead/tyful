<?xml version="1.0" encoding="utf-8"?>
<mx:UIComponent creationComplete="onCreationComplete(event)" 
				enterFrame="enterFrameHandler(event)" 
				xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" width="100%" height="100%"
		 >
	<fx:Declarations>
		<mx:ProgressBar id="renderProgressBar" mode="manual" maximum="100" minimum="0">
		</mx:ProgressBar>
<!--		<s:List id="lostWordList" right="0" top="0" bottom="0" width="150" verticalCenter="0" dataProvider="{this.lostWords}" ></s:List>
		<s:Group id="canvas" left="0" right="150" top="0" bottom="0" verticalCenter="0">
		</s:Group>
	-->	
	</fx:Declarations>
	
	
	<fx:Script>
		<![CDATA[
			import com.settinghead.wexpression.client.RenderOptions;
			import com.settinghead.wexpression.client.placer.ShapeConfinedPlacer;
			import com.settinghead.wexpression.client.nudger.ShapeConfinedSpiralWordNudger;
			import com.settinghead.wexpression.client.WordComparator;
			import com.settinghead.wexpression.client.WordCramEngine;
			import com.settinghead.wexpression.client.WordSorterAndScaler;
			import com.settinghead.wexpression.client.model.vo.WordVO;
			import com.demonsters.debugger.MonsterDebugger;
			import com.settinghead.wexpression.client.angler.MostlyHorizAngler;
			import com.settinghead.wexpression.client.angler.ShapeConfinedAngler;
			import com.settinghead.wexpression.client.angler.WordAngler;
			import com.settinghead.wexpression.client.colorer.AlwaysUseColorer;
			import com.settinghead.wexpression.client.colorer.TwoHuesRandomSatsColorer;
			import com.settinghead.wexpression.client.colorer.WordColorer;
			import com.settinghead.wexpression.client.density.DensityPatchIndex;
			import com.settinghead.wexpression.client.fonter.AlwaysUseFonter;
			import com.settinghead.wexpression.client.fonter.WordFonter;
			import com.settinghead.wexpression.client.model.vo.TemplateVO;
			import com.settinghead.wexpression.client.nudger.WordNudger;
			import com.settinghead.wexpression.client.placer.WordPlacer;
			import com.settinghead.wexpression.client.sizers.ByRankWordSizer;
			import com.settinghead.wexpression.client.sizers.ByWeightSizer;
			import com.settinghead.wexpression.client.sizers.WordSizer;
			import com.settinghead.wexpression.client.test.TextSource;
			
			import flash.display.BitmapData;
			import flash.display.Graphics;
			import flash.display.Sprite;
			import flash.events.Event;
			import flash.events.MouseEvent;
			import flash.net.FileReference;
			import flash.sampler.NewObjectSample;
			import flash.utils.ByteArray;
			
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.graphics.codec.PNGEncoder;
			
			import org.as3commons.collections.ArrayList;
			import org.as3commons.collections.SortedList;
			import org.as3commons.collections.utils.NullComparator;
			/*
			* This class is really only two parts: the fluent builder API, and
			* pass-through calls to the WordCramEngine, where all the work happens.
			* This separation keeps the classes focused on only one thing, but still
			* gives the user a pretty nice API.
			*/
		
			
			/**
			 * Skip Reason: the Word was skipped because
			 * {@link #maxNumberOfWordsToDraw(int)} was set to some value, and the Word
			 * came in over that limit. It's really about the Word's rank, its position
			 * in the list once the words are sorted by weight: if its rank is greater
			 * than the value passed to maxNumberOfWordsToDraw(), then it'll be skipped,
			 * and this will be the reason code.
			 */
			public static const WAS_OVER_MAX_NUMBER_OF_WORDS:int= 301;
			
			/**
			 * Skip Reason: the Word's shape was too small. WordCram will only render
			 * words so small, for performance reasons. You can set the minimum Word
			 * shape size via {@link #minShapeSize(int)}.
			 */
			public static const SHAPE_WAS_TOO_SMALL:int= 302;
			
			/**
			 * Skip Reason: WordCram tried placing the Word, but it couldn't find a
			 * clear spot. The {@link WordNudger} nudged it around a bunch (according to
			 * {@link #maxAttemptsToPlaceWord(int)}, if it was set), but there was just
			 * no room.
			 */
			public static const NO_SPACE:int= 303;
			
			private var _words:SortedList  = null;
			private var extraStopWords:String= "";
			private var _excludeNumbers:Boolean= true;
			
			private static const TextCase_Lower:int = 0;
			private static const TextCase_Upper:int = 1;
			private static const TextCase_Keep:int = 2;
			
			private var wordLoadingComplete:Boolean = false;
			private var textCase:int= TextCase_Keep;
			
			private var wordCramEngine:WordCramEngine;
			
			
			private var fonter:WordFonter;
			private var sizer:WordSizer;
			private var colorer:WordColorer;
			private var angler:WordAngler;
			private var placer:WordPlacer;
			private var nudger:WordNudger;
			
			private var renderOptions:RenderOptions= new RenderOptions();
			
			private var img:TemplateVO;
			private var lostWords:Vector.<WordVO> = new Vector.<WordVO>();
			
//			public function WordCramRenderer()
//			{
//				super();
//				addEventListener(FlexEvent.CREATION_COMPLETE, function(event:FlexEvent):void {
//					renderStuff();
//				});
//				
//			}
			
			
			public function onCreationComplete(evt:FlexEvent):void{
				//renderWords();
//				loadWords();
				
			}
			
			public function loadWords():void{
				
				if(this.words==null){
					this.words =  new SortedList(new WordComparator());
					this.wordLoadingComplete = false;
					for(var i:int=0;i<60;i++){
						this.addWord(new WordVO("Freedomize", Math.random()*5+0.5));
						this.addWord(new WordVO("CaRR", Math.random()*5+0.5));
						this.addWord(new WordVO("eclipse", Math.random()*5+0.5));
						this.addWord(new WordVO("carz", Math.random()*5+0.5));
						this.addWord(new WordVO("sand", Math.random()*5+0.5));
						this.addWord(new WordVO("beach", Math.random()*5+0.5));
						this.addWord(new WordVO("stephen", Math.random()*5+0.5));
						this.addWord(new WordVO("Bloom", Math.random()*5+0.5));
					}
				}
			}
			
			public function renderWords():void{
				this.wordLoadingComplete = true;

				this.graphics.lineStyle(0.5);
				
//				this.drawAll();
				
				this.addChild(this.renderProgressBar);
				if(this.hasMore())
					this.drawNext();
			}
			
			
			/**
			 * Tells WordCram which words to ignore when it counts up the words in your
			 * text. These words won't show up in the image.
			 * <p>
			 * Stop-words are always case-insensitive: if your source text contains "The
			 * plane, the
			 * plane!", using "the" for a stop-word is enough to block both "the
			 * " and "The".
			 * <p>
			 * It doesn't matter whether this is called before or after the "for{text}"
			 * methods.
			 * <p>
			 * <b><i>Note:</i></b> Stop-words have no effect if you're passing in your
			 * own custom {@link Word} array, since WordCram won't do any text analysis
			 * on it (other than sorting the words and scaling their weights).
			 * 
			 * @param extraStopWords
			 *            a space-delimited String of words to ignore when counting the
			 *            words in your text.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withStopWords(extraStopWords:String):WordCramRenderer {
				this.extraStopWords = extraStopWords;
				return this;
			}
			
			/**
			 * Exclude numbers from the text in the WordCram. They're excluded by
			 * default.
			 * <p>
			 * Words that are all numbers, like 1, 3.14159, 42, or 1492, will be
			 * excluded. Words that have some letters and some numbers like 1A, U2, or
			 * funnyguy194 will be included.
			 * 
			 * @see #includeNumbers()
			 * @return The WordCram, for further setup or drawing.
			 */
			public function excludeNumbers():WordCramRenderer {
				this._excludeNumbers = true;
				return this;
			}
			
			/**
			 * Include numbers from the text in the WordCram. They're excluded by
			 * default.
			 * 
			 * @see #excludeNumbers()
			 * @return The WordCram, for further setup or drawing.
			 */
			public function includeNumbers():WordCramRenderer {
				this._excludeNumbers = false;
				return this;
			}
			
			/**
			 * Make the WordCram change all words to lower-case. Stop-words are
			 * unaffected; they're always case-insensitive. The default is to keep words
			 * as they appear in the text.
			 * 
			 * @return The WordCram, for further setup or drawing.
			 */
			public function lowerCase():WordCramRenderer {
				this.textCase = TextCase_Lower;
				var s:String;
				return this;
			}
			
			/**
			 * Make the WordCram change all words to upper-case. Stop-words are
			 * unaffected; they're always case-insensitive. The default is to keep words
			 * as they appear in the text.
			 * 
			 * @return The WordCram, for further setup or drawing.
			 */
			public function upperCase():WordCramRenderer {
				this.textCase = TextCase_Upper;
				return this;
			}
			
			/**
			 * Make the WordCram leave all words cased as they appear in the text.
			 * Stop-words are unaffected; they're always case-insensitive. This is the
			 * default.
			 * 
			 * @return The WordCram, for further setup or drawing.
			 */
			public function keepCase():WordCramRenderer {
				this.textCase = TextCase_Keep;
				return this;
			}
			
			/**
			 * Makes a WordCram from your own custom Word array. The Words can be
			 * ordered and weighted arbitrarily - WordCram will sort them by weight, and
			 * then divide their weights by the weight of the heaviest Word, so the
			 * heaviest Word will end up with a weight of 1.0.
			 * 
			 * <p>
			 * Note: WordCram won't do any text analysis on the words; stop-words will
			 * have no effect, etc. These words are supposed to be ready to go.
			 * 
			 * @return The WordCram, for further setup or drawing.
			 */
			public function set words(_words:SortedList):void {
				this._words = _words;
			}
			
			public function get words():SortedList {
				return this._words;
			}
			
			// ----------------------------------------------
			
			/**
			 * This WordCram will get a <a
			 * href="http://processing.org/reference/PFont.html"
			 * target="blank">PFont</a> for each fontName, via <a
			 * href="http://processing.org/reference/createFont_.html"
			 * target="blank">createFont</a>, and will render words in one of those
			 * PFonts.
			 * 
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withFonts( ... fontNames):WordCramRenderer {
				var fonts:Vector.<String>= new Vector.<String>;
				for (var i:int= 0; i < fontNames.length; i++) {
					fonts.push(fontNames[i]);
				}
				
				return withFonts(fonts);
			}
			
			
			/**
			 * Use the given WordFonter to pick fonts for each word. You can make your
			 * own, or use a pre-fab one from {@link Fonters}.
			 * 
			 * @see WordFonter
			 * @see Fonters
			 * @param fonter
			 *            the WordFonter to use.
			 * @return The WordCram, for further setup or drawing.
			 */
			/*
			* = Here is a bit of a play-ground for now, to see how this might work. See
			* docgen.rb. example withFonter({your WordFonter}) example
			* withFonter(Fonters.alwaysUse("Comic Sans")) example withFonter(new
			* WordFonter() { ... (how to doc-gen this?) =
			*/
			public function withFonter(fonter:WordFonter):WordCramRenderer {
				this.fonter = fonter;
				return this;
			}
			
			/**
			 * Make the WordCram size words by their weight, where the "heaviest" word
			 * will be sized at <code>maxSize</code>.
			 * 
			 * <p>
			 * Specifically, it makes the WordCram use {@link Sizers#byWeight(int, int)}.
			 * 
			 * @param minSize
			 *            the size to draw a Word of weight 0
			 * @param maxSize
			 *            the size to draw a Word of weight 1
			 * @return The WordCram, for further setup or drawing.
			 */
			/* =example sizedByWeight(int minSize, int maxSize)= */
			public function sizedByWeight(minSize:int, maxSize:int):WordCramRenderer {
				return withSizer(new ByWeightSizer(minSize, maxSize));
			}
			
			/**
			 * Make the WordCram size words by their rank. The first word will be sized
			 * at <code>maxSize</code>.
			 * 
			 * <p>
			 * Specifically, it makes the WordCram use {@link Sizers#byRank(int, int)}.
			 * 
			 * @param minSize
			 *            the size to draw the last Word
			 * @param maxSize
			 *            the size to draw the first Word
			 * @return The WordCram, for further setup or drawing.
			 */
			/* =example sizedByRank(int minSize, int maxSize)= */
			public function sizedByRank(minSize:int, maxSize:int):WordCramRenderer {
				return withSizer( new ByRankWordSizer(minSize, maxSize));
			}
			
			/**
			 * Use the given WordSizer to pick fonts for each word. You can make your
			 * own, or use a pre-fab one from {@link Sizers}.
			 * 
			 * @see WordSizer
			 * @see Sizers
			 * @param sizer
			 *            the WordSizer to use.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withSizer(sizer:WordSizer):WordCramRenderer {
				this.sizer = sizer;
				return this;
			}
			
			
			/**
			 * Use the given WordColorer to pick colors for each word. You can make your
			 * own, or use a pre-fab one from {@link Colorers}.
			 * 
			 * @see WordColorer
			 * @see Colorers
			 * @param colorer
			 *            the WordColorer to use.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withColorer(colorer:WordColorer):WordCramRenderer {
				this.colorer = colorer;
				return this;
			}
			
			
			
			/**
			 * Use the given WordAngler to pick angles for each word. You can make your
			 * own, or use a pre-fab one from {@link Anglers}.
			 * 
			 * @see WordAngler
			 * @see Anglers
			 * @param angler
			 *            the WordAngler to use.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withAngler(angler:WordAngler):WordCramRenderer {
				this.angler = angler;
				return this;
			}
			
			/**
			 * Use the given WordPlacer to pick locations for each word. You can make
			 * your own, or use a pre-fab one from {@link Placers}.
			 * 
			 * @see WordPlacer
			 * @see Placers
			 * @see PlottingWordPlacer
			 * @param placer
			 *            the WordPlacer to use.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withPlacer(placer:WordPlacer):WordCramRenderer {
				this.placer = placer;
				return this;
			}
			
			/**
			 * Use the given WordNudger to pick angles for each word. You can make your
			 * own, or use a pre-fab one.
			 * 
			 * @see WordNudger
			 * @see SpiralWordNudger
			 * @see RandomWordNudger
			 * @see PlottingWordNudger
			 * @param nudger
			 *            the WordNudger to use.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withNudger(nudger:WordNudger):WordCramRenderer {
				this.nudger = nudger;
				return this;
			}
			
			/**
			 * How many attempts should be used to place a word. Higher values ensure
			 * that more words get placed, but will make algorithm slower.
			 * 
			 * @param maxAttempts
			 * @return The WordCram, for further setup or drawing.
			 */
			public function maxAttemptsToPlaceWord(maxAttempts:int):WordCramRenderer {
				renderOptions.maxAttemptsToPlaceWord = maxAttempts;
				return this;
			}
			
			/**
			 * The maximum number of Words WordCram should try to draw. This might be
			 * useful if you have a whole bunch of words, and need an artificial way to
			 * cut down the list (for speed). By default, it's unlimited.
			 * 
			 * @param maxWords
			 *            can be any value from 0 to Integer.MAX_VALUE. Values < 0 are
			 *            treated as unlimited.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function maxNumberOfWordsToDraw(maxWords:int):WordCramRenderer {
				renderOptions.maxNumberOfWordsToDraw = maxWords;
				return this;
			}
			
			/**
			 * The smallest-sized Shape the WordCram should try to draw. By default,
			 * it's 7.
			 * 
			 * @param minShapeSize
			 *            the size of the smallest Shape.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function minShapeSize(minShapeSize:int):WordCramRenderer {
				renderOptions.minShapeSize = minShapeSize;
				return this;
			}
			
		
			
			public function set template(img:TemplateVO):void {
				reset();
				this.img = img;
				placer = new ShapeConfinedPlacer(img, new DensityPatchIndex(img));
				nudger = new ShapeConfinedSpiralWordNudger();
				angler = new ShapeConfinedAngler(img, new MostlyHorizAngler());
				colorer = new TwoHuesRandomSatsColorer();
				loadWords();
				this.renderWords();
				//this.drawNext();
			}
			
			/**
			 * Add padding around each word, so they stand out from each other more. If
			 * you call this multiple times, the last value will be used.
			 * 
			 * WordCram uses a tree of java.awt.Rectangle objects to detect whether two
			 * words overlap. What this method actually does is call
			 * <code>Rectangle.grow(padding)</code> on the leaves of that tree.
			 * 
			 * @param padding
			 *            The number of pixels to grow each rectangle by. Defaults to
			 *            zero.
			 * @return The WordCram, for further setup or drawing.
			 */
			public function withWordPadding(padding:int):WordCramRenderer {
				renderOptions.wordPadding = padding;
				return this;
			}
			
			public function getWordCramEngine():WordCramEngine {
				if (wordCramEngine == null) {
					
					words = WordSorterAndScaler.sortAndScale(words);
					
					if (fonter == null)
						fonter = new AlwaysUseFonter("Vera");
					if (sizer == null)
						sizer = new ByWeightSizer(8, 35);
					if (colorer == null)
						colorer = new TwoHuesRandomSatsColorer();
					if (angler == null)
						angler = new MostlyHorizAngler();
					if (placer == null)
//						placer = new ShapeConfinedPlacer(img, new DensityPatchIndex(img));
						placer = new ShapeConfinedPlacer(this.img, new DensityPatchIndex(this.img));
					if (nudger == null)
						nudger = new ShapeConfinedSpiralWordNudger();
					
					
					this.wordCramEngine = new WordCramEngine(this, words, fonter,
						sizer, colorer, angler, placer, nudger, renderOptions,  img);
				}
				
				return wordCramEngine;
			}
			
			/**
			 * If you're drawing the words one-at-a-time using {@link #drawNext()}, this
			 * will tell you whether the WordCram has any words left to draw.
			 * 
			 * @return true if the WordCram has any words left to draw; false otherwise.
			 * @see #drawNext()
			 */
			public function hasMore():Boolean {
				return getWordCramEngine().hasMore();
			}
			
			/**
			 * If the WordCram has any more words to draw, draw the next one.
			 * 
			 * @see #hasMore()
			 * @see #drawAll()
			 */
			public function drawNext():void {
				getWordCramEngine().drawNext();
//				if(getWordCramEngine().failedLast)
//					this.lostWords.push(words.itemAt(getWordCramEngine().currentEngineWordIndex));
				if(getWordCramEngine().currentEngineWordIndex+1>=words.size)
					this.removeChild(this.renderProgressBar);
				this.renderProgressBar.setProgress(getWordCramEngine().currentEngineWordIndex+1,words.size);
			}
			
			/**
			 * Just like it sounds: draw all the words. Once the WordCram has everything
			 * set, call this and wait just a bit.
			 * 
			 * @see #drawNext()
			 */
			
			
			public function drawAll():void {
//				getWordCramEngine().drawAll();
				while (getWordCramEngine().hasMore()) {
					getWordCramEngine().drawNext();
				}
			}
			
			/**
			 * Get the Words that WordCram is drawing. This can be useful if you want to
			 * inspect exactly how the words were weighted, or see how they were
			 * colored, fonted, sized, angled, or placed, or why they were skipped.
			 */
			public function getWords():SortedList {
				return words;
			}
			
			/**
			 * Get the Word at the given (x,y) coordinates.
			 * 
			 * <p>
			 * This can be called while the WordCram is rendering, or after it's done.
			 * If a Word is too small to render, or hasn't been placed yet, it will
			 * never be returned by this method.
			 * 
			 * @param x
			 *            the X coordinate
			 * @param y
			 *            the Y coordinate
			 * @return the Word that covers those coordinates, or null if there isn't
			 *         one
			 */
			public function getWordAt(x:Number, y:Number):WordVO {
				return getWordCramEngine().getWordAt(x, y);
			}
			
			/**
			 * Returns an array of words that could not be placed.
			 * 
			 * @return An array of the skipped words
			 */
			public function getSkippedWords():Vector.<WordVO> {
				return getWordCramEngine().getSkippedWords();
			}
			
			/**
			 * How far through the words are we? Useful for when drawing to a custom
			 * Graphics.
			 * 
			 * @return The current point of progress through the list, as a float
			 *         between 0 and 1.
			 */
			public function getProgress():Number {
				return getWordCramEngine().getProgress();
			}
			
			
			public function reset():void {
//				this.graphics.beginFill(0x010101,1.0);
//				this.graphics.drawRect(0,0, this.width, this.height);
//				this.graphics.endFill();
				this.img = null;
				this.wordCramEngine = null;
				this.placer = null;
				this.nudger = null;
				this.angler = null;
//				words = null;
				this.colorer = null;
				var k:int = this.numChildren;
				while( k -- )
				{
					this.removeChildAt( k );
				}
				
			}
			
			
			
			public function addWord(w:WordVO):void {
				if (words == null)
					words = new SortedList(new WordComparator());
				words.add(w);
				
			}

			protected function enterFrameHandler(event:Event):void
			{
				if(this.wordLoadingComplete && this.hasMore())
					this.drawNext();
			}
			
			
		]]>
	</fx:Script>
	
</mx:UIComponent>
