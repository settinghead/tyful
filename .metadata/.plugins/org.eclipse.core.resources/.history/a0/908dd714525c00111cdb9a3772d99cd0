package com.settinghead.wexpression.client.model
{
	import com.settinghead.wexpression.client.ApplicationFacade;
	import com.settinghead.wexpression.client.PlaceInfo;
	import com.settinghead.wexpression.client.RenderOptions;
	import com.settinghead.wexpression.client.WordShaper;
	import com.settinghead.wexpression.client.angler.MostlyHorizAngler;
	import com.settinghead.wexpression.client.angler.ShapeConfinedAngler;
	import com.settinghead.wexpression.client.angler.WordAngler;
	import com.settinghead.wexpression.client.colorer.WordColorer;
	import com.settinghead.wexpression.client.density.Patch;
	import com.settinghead.wexpression.client.fonter.WordFonter;
	import com.settinghead.wexpression.client.model.vo.DisplayWordVO;
	import com.settinghead.wexpression.client.model.vo.EngineWordVO;
	import com.settinghead.wexpression.client.model.vo.TextShapeVO;
	import com.settinghead.wexpression.client.model.vo.TuVO;
	import com.settinghead.wexpression.client.model.vo.WordListVO;
	import com.settinghead.wexpression.client.model.vo.WordVO;
	import com.settinghead.wexpression.client.model.vo.template.TemplateVO;
	import com.settinghead.wexpression.client.nudger.WordNudger;
	import com.settinghead.wexpression.client.placer.ShapeConfinedPlacer;
	import com.settinghead.wexpression.client.placer.WordPlacer;
	import com.settinghead.wexpression.client.sizers.WordSizer;
	
	import flash.display.DisplayObject;
	import flash.display.Graphics;
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.geom.Rectangle;
	
	import mx.collections.ArrayCollection;
	import mx.controls.Alert;
	import mx.graphics.codec.PNGEncoder;
	import mx.rpc.IResponder;
	
	import org.as3commons.collections.SortedList;
	import org.as3commons.collections.framework.IIterator;
	import org.puremvc.as3.interfaces.IProxy;
	import org.puremvc.as3.patterns.proxy.Proxy;
	import org.puremvc.as3.utilities.loadup.interfaces.ILoadupProxy;
	
	public class TuProxy extends EntityProxy implements ILoadupProxy
	{
		public static const NAME:String = "TuProxy";
		public static const SRNAME:String = "TuSRProxy";
		
		private var _template:TemplateVO;
		private var _wordList:WordListVO;
		
		public function TuProxy()
		{
			super(NAME, new ArrayCollection());

		}
		
		// return data property cast to proper type
		public function get tu():TuVO
		{
			return data as TuVO;
		}
		
		public function load() :void{
			var tu:TuVO = new TuVO(_template, _wordList);
			this.setData(tu);
			facade.sendNotification(ApplicationFacade.TU_INITIALIZED);

		}
		
		public function set template(t:TemplateVO):void{
			this._template = t;
		}
		
		public function set wordList(wl:WordListVO):void{
			this._wordList = wl;
		}

		private var _previewGenerationResponder:IResponder;
		public function get previewGenerationResponder():IResponder{
			return _previewGenerationResponder;
		}

		public function set previewGenerationResponder(r:IResponder):void{
			this._previewGenerationResponder = r;
		}
		
		private var failureCount:int = 0;
		public function renderNextDisplayWord():void{
			var count:int = 0;
			while(!tu.finishedDisplayWordRendering && ++count<3) {
			
				//TODO
				var eWord:EngineWordVO = null;
				var word:WordVO = null;
				
				word = tu.getNextWordAndIncrement();
	
				if(word==null) return;
				eWord = generateEngineWord(word);
	
				if(eWord!=null){
					placeWord(eWord);
	
	//				if (eWord.wasSkipped()){
					while (eWord.wasSkipped()){
						if(tu.indexOffset+tu.currentWordIndex==tu.words.size - 1)
							break;
						tu.indexOffset+=tu.words.size/15;
						if(tu.indexOffset+tu.currentWordIndex>tu.words.size)
						{
							tu.indexOffset = tu.words.size -1;
							break;
						}
						eWord = generateEngineWord(word);
						placeWord(eWord);
					}				
			
					tu.pushEngineWord(eWord);
					var dw:DisplayWordVO = null;
					if(!eWord.wasSkipped()){
						failureCount = 0;
						dw = eWord.rendition(tu.template.colorer.colorFor(word));
						tu.dWords.addItem(dw);
					}
					else{
						failureCount ++;
						
						//5 consecutive failures. Put rendering to an end.
						if (failureCount > tu.template.diligence){
							tu.finishedDisplayWordRendering = true;
							sendNotification(ApplicationFacade.TU_GENERATION_LAST_CALL);
						}
	
					}
	
					if(tu.finishedDisplayWordRendering && this.previewGenerationResponder!=null){
	
						var encoder:PNGEncoder = new PNGEncoder();
						tu.template.previewPNG = encoder.encode(tu.generatedImage);
						this.previewGenerationResponder.result(null);
					}
					sendNotification(ApplicationFacade.DISPLAYWORD_CREATED, dw);
				}
			}
		}
		
		
		public function generateEngineWord(word:WordVO):EngineWordVO{
			var newIndex:int = tu.currentWordIndex+tu.indexOffset<tu.words.size?tu.currentWordIndex+tu.indexOffset:tu.words.size;
			var eWord:EngineWordVO= new EngineWordVO(word, newIndex);
			
			eWord.wordFont = tu.template.fonter.fontFor(word);
			eWord.wordSize = tu.template.sizer.sizeFor(word,newIndex,tu.words.size);
			
			var shape:TextShapeVO= WordShaper.makeShape(word.word, eWord.wordSize, eWord.wordFont, 0);
			if (shape == null) {
				eWord.wasSkippedBecause(EngineWordVO.SKIP_REASON_SHAPE_TOO_SMALL);
			} else {
				eWord.setShape(shape, tu.template.renderOptions.wordPadding);
			}
			
			return eWord;
		}
		
		private function calculateMaxAttemptsFromWordWeight(eWord:EngineWordVO, p:Patch):int {
			return (p.getWidth() * p.getHeight())  / (eWord.shape.width * eWord.shape.height) * 20 
				* (1+ Math.random() * 0.4)
				;
			//			var area:Number = p.getWidth() * p.getHeight();
			//			var result:int = area / 10000 * int(((1.0 - word.weight) * 60) )+ 30 + 40*Math.random();
			//			Assert.isTrue(result>0);
			//			return result;
		}
		
		public function placeWord(eWord:EngineWordVO):Boolean {
//			tu.totalCount++;
//			tu.failedLastVar = false;
			var word:WordVO= eWord.word;
			
			// these into
			// EngineWord.setDesiredLocation?
			// Does that make
			// sense?
			var wordImageWidth:int= int(eWord.shape.textField.width);
			var wordImageHeight:int= int(eWord.shape.textField.height);
			
			eWord.retrieveDesiredLocations(tu.template.placer, tu.eWords.length,
				wordImageWidth, wordImageHeight, template.width,
				template.height);
			// Set maximum number of placement trials
			
			
			while(eWord.hasNextDesiredLocation()){
				var candidateLoc:PlaceInfo = eWord.nextDesiredLocation();
				
				var maxAttemptsToPlace:int= template.renderOptions.maxAttemptsToPlaceWord > 0? template.renderOptions.maxAttemptsToPlaceWord
					: calculateMaxAttemptsFromWordWeight(eWord, candidateLoc.patch);
				
				var lastCollidedWith:EngineWordVO = null;
				var attempt:int;
				//				var neighboringPatches:Set = candidateLoc.patch.neighborsAndMe;
				//				var neighboringEWords:Vector.<EngineWordVO> = new Vector.<EngineWordVO>();
				
				//				var iter:org.as3commons.collections.framework.IIterator = neighboringPatches.iterator();
				
				//				
				//				while(iter.hasNext()){
				//					var p:Patch = iter.next();
				//					for each (var ew:EngineWordVO in p.eWords)
				//						neighboringEWords.push(ew);
				//					var ao:Vector.<Patch> = p.ancestorsAndOffsprngs();
				//					for each (var p1:Patch in ao){
				//						for each (var ew:EngineWordVO in p1.eWords)
				//							neighboringEWords.push(ew);
				//					}
				//				}
				
				
				inner: for (attempt= 0; attempt < maxAttemptsToPlace; attempt++) {
					eWord.nudgeTo(candidateLoc.getpVector().add(template.nudger.nudgeFor(word, candidateLoc,
						attempt,maxAttemptsToPlace)), candidateLoc.patch);
					
					var angle:Number= candidateLoc.patch.layer.angler.angleFor(eWord);
					//			eWord.getTree().draw(destination.graphics);
					
					// // TODO
					eWord.getTree().setRotation(angle);
					//
					if (eWord.trespassed(candidateLoc.patch.layer))
						continue;
					var loc:PlaceInfo= eWord.getCurrentLocation();
					if (loc.getpVector().x < 0|| loc.getpVector().y < 0|| loc.getpVector().x + wordImageWidth >= template.width
						|| loc.getpVector().y + wordImageHeight >= template.height) {
						continue;
					}
					
					if (lastCollidedWith != null && eWord.overlaps(lastCollidedWith)) {
						continue;
					}
					
					
					//					for (var i:int= 0; !foundOverlap && i < neighboringEWords.length; i++) {
					for (var i:int= 0;  i < _currentWordIndex; i++) {
						//						var otherWord:EngineWordVO= neighboringEWords[i];
						var otherWord:EngineWordVO = _eWords[i];
						if (otherWord.wasSkipped()) continue; //can't overlap with skipped word
						
						if (eWord.overlaps(otherWord)) {
							
							lastCollidedWith = otherWord;
							continue inner;
						}
					}
					
					candidateLoc.patch.mark(wordImageWidth*wordImageHeight, false);
					template.placer.success(eWord.desiredLocations);
					eWord.finalizeLocation();
					successCount++;
					candidateLoc.patch.lastAttempt = attempt;
					return true;
				}
				candidateLoc.patch.lastAttempt = attempt;
				candidateLoc.patch.fail();
			}
			
			eWord.wasSkippedBecause(EngineWordVO.SKIP_REASON_NO_SPACE);
			//			info.patch.mark(wordImageWidth*wordImageHeight, true);
			this.template.placer.fail(eWord.desiredLocations);
			this.failedLastVar = true;
			return false;
		}
		
	}
}