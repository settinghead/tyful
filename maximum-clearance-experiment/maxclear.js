// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var $img;
    $img = $("<img>", {
      src: "test.png"
    });
    return $img.load(function() {
      $('#source')[0].width = this.height;
      $('#source')[0].height = this.height;
      $('#source')[0].getContext('2d').drawImage(this, 0, 0, $('#source')[0].width, $('#source')[0].height);
      window.maxClearance = new MaxClearance($('#source')[0], $('#main')[0]);
      return window.maxClearance.compute();
    });
  });

  Array.prototype.nearestVertex = function(v) {
    return [0];
  };

  window.MaxClearance = (function() {

    function MaxClearance(sourceCanvasEl, destCanvasEl) {
      this.source = sourceCanvasEl;
      this.main = destCanvasEl;
      this.sourceContext = this.source.getContext('2d');
      this.mainContext = this.main.getContext('2d');
      this.main.width = this.source.width;
      this.main.height = this.source.height;
      this.data = this.sourceContext.getImageData(0, 0, main.width, main.height).data;
    }

    MaxClearance.prototype.getAlpha = function(x, y) {
      var v;
      return v = this.data[(y * main.width + x) * 4 + 3];
    };

    MaxClearance.prototype.compute = function() {
      var alpha, dist, n, newVertices, v, vTop, vj, vk, x, y, _i, _j, _len, _len1, _results;
      n = main.width;
      this.A = [];
      this.partitions = [1.7976931348623157e10308, -1.7976931348623157e10308];
      this.stack = [];
      this.distData = new Uint32Array(this.main.width * this.main.height);
      this.maxdist = Math.sqrt(Math.pow(this.main.width, 2) + Math.pow(this.main.height, 2));
      x = 0;
      _results = [];
      while (x < n) {
        y = 0;
        newVertices = [];
        while (y < n) {
          alpha = this.getAlpha(x, y);
          if (alpha > 0) {
            v = new Vertex(x, y);
            v.alpha = alpha;
            this.A[y] = v;
            newVertices.push(v);
          }
          y++;
        }
        if (!this.stack.length) {
          for (_i = 0, _len = newVertices.length; _i < _len; _i++) {
            vj = newVertices[_i];
            if (this.stack.length) {
              vTop = this.stack[this.stack.length - 1];
              y = vj.getIntersectionY(vTop, vj.x, MaxClearance.Direction.eastBound);
              vTop.upperBound = vj.lowerBound = y;
            }
            this.stack.push(vj);
            vj.setSelected();
          }
        } else {
          for (_j = 0, _len1 = newVertices.length; _j < _len1; _j++) {
            vj = newVertices[_j];
            if (vj && !vj.isSubsumed() && !vj.isSelected()) {
              vk = this.stack[this.stack.length - 1];
              y = vj.getIntersectionY(vk, x, MaxClearance.Direction.eastBound);
              while (vj.y >= vk.y) {
                console.assert(!vk.isSubsumed());
                if (y <= vk.lowerBound || vj.y === vk.y) {
                  v = this.stack.pop();
                  console.assert(v === vk);
                  vk.setSubsumed(vj);
                  vk = this.stack[this.stack.length - 1];
                  y = vj.getIntersectionY(vk, x, MaxClearance.Direction.eastBound);
                } else {
                  vj.upperBound = 1.7976931348623157e10308;
                  vk.upperBound = vj.lowerBound = y;
                  this.stack.push(vj);
                  vj.setSelected();
                  break;
                }
              }
            }
          }
        }
        y = 0;
        while (y < n) {
          v = this.stack.nearestVertex(y);
          dist = this.distance(x, y, v.x, v.y);
          this.distData[x + y * main.width] = dist;
          this.mainContext.fillStyle = "rgb(255,255," + (dist / this.maxdist) + ")";
          this.mainContext.rect(x, y, 1, 1);
          y++;
        }
        _results.push(x++);
      }
      return _results;
    };

    MaxClearance.Direction = {
      eastBound: 0,
      westBound: 1
    };

    MaxClearance.prototype.distance = function(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(y2 - y1) + Math.pow(x2 - x1));
    };

    return MaxClearance;

  })();

  window.Vertex = (function() {

    function Vertex(x, y) {
      this.x = x;
      this.y = y;
      this.upperBound = 1.7976931348623157e10308;
      this.lowerBound = -1.7976931348623157e10308;
    }

    Vertex.prototype.getIntersectionY = function(vertex, x, direction) {
      var atanRatio, midX, midY, y;
      if (direction === MaxClearance.Direction.eastBound) {
        midY = (vertex.y + this.y) / 2;
        if (vertex.x === this.x) {
          y = midY;
        } else {
          midX = (vertex.x + this.x) / 2;
          atanRatio = (vertex.y - this.y) / (vertex.x - this.x);
          y = (midX - x) * atanRatio + midY;
        }
        return y;
      } else if (direction === MaxClearance.Direction.westBound) {
        return alert('not implemented');
      }
    };

    Vertex.prototype.isSubsumed = function() {
      if (this.subsumed) {
        return true;
      } else {
        return false;
      }
    };

    Vertex.prototype.isSelected = function() {
      if (this.selected) {
        return true;
      } else {
        return false;
      }
    };

    Vertex.prototype.setSubsumed = function(v) {
      console.assert(this.selected);
      this.subsumedBy = v;
      return this.subsumed = true;
    };

    Vertex.prototype.setSelected = function() {
      return this.selected = true;
    };

    Vertex.prototype.toString = function() {
      return "(" + this.x + "," + this.y + ")";
    };

    return Vertex;

  })();

}).call(this);
