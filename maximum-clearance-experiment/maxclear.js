// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var $img;
    $img = $("<img>", {
      src: "test.png"
    });
    return $img.load(function() {
      $('#source')[0].width = this.height;
      $('#source')[0].height = this.height;
      $('#source')[0].getContext('2d').drawImage(this, 0, 0, $('#source')[0].width, $('#source')[0].height);
      window.maxClearance = new MaxClearance($('#source')[0], $('#main')[0]);
      return window.maxClearance.compute();
    });
  });

  Array.prototype.nearestVertex = function(v) {
    return this[0];
  };

  window.MaxClearance = (function() {
    var Vertex;

    function MaxClearance(sourceCanvasEl, destCanvasEl) {
      this.source = sourceCanvasEl;
      this.main = destCanvasEl;
      this.sourceContext = this.source.getContext('2d');
      this.mainContext = this.main.getContext('2d');
      this.main.width = this.source.width;
      this.main.height = this.source.height;
      this.data = this.sourceContext.getImageData(0, 0, main.width, main.height).data;
    }

    MaxClearance.prototype.getAlpha = function(x, y) {
      var v;
      return v = this.data[(y * main.width + x) * 4 + 3];
    };

    MaxClearance.prototype.compute = function() {
      var alpha, direction, dist, entered_range, i, in_range, n, newVertices, pos, v, val, vj, vk, where, xc, y, _i, _len, _ref, _results;
      n = main.width;
      this.A = [];
      this.partitions = [1.7976931348623157e10308, -1.7976931348623157e10308];
      this.distData = new Uint32Array(this.main.width * this.main.height);
      this.maxdist = Math.sqrt(Math.pow(this.main.width, 2) + Math.pow(this.main.height, 2));
      i = 0;
      xc = 0;
      direction = MaxClearance.Direction.eastBound;
      _results = [];
      while (xc < n) {
        y = 0;
        newVertices = [];
        while (y < n) {
          alpha = this.getAlpha(xc, y);
          if (alpha > 0) {
            v = new Vertex(xc, y);
            v.alpha = alpha;
            this.A[y] = v;
            newVertices.push(v);
          }
          y++;
        }
        _ref = this.A;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vj = _ref[_i];
          if (vj && !vj.isSubsumed() && !vj.isSelected()) {
            if (!this.begin) {
              this.begin = this.end = vj;
              vj.setSelected();
            } else {
              in_range = true;
              entered_range = false;
              pos = void 0;
              where = void 0;
              vk = this.end;
              while (vk) {
                if (!vk.isSubsumed()) {
                  y = vj.getIntersectionY(vk, xc, direction);
                  if (vj.y > vk.y) {
                    if (y < vk.lowerBound) {
                      pos = this.subsume(vk, vj);
                      where = MaxClearance.Where.self;
                      this.updateBounds(vj, xc, direction);
                      if (!entered_range) {
                        entered_range = true;
                      }
                    } else if (y < vk.upperBound) {
                      pos = vk;
                      where = MaxClearance.Where.upper;
                      this.updateBounds(vj, xc, direction);
                      if (!entered_range) {
                        entered_range = true;
                      }
                    } else if (entered_range) {
                      break;
                    }
                  } else if (vj.y === vk.y) {
                    pos = this.subsume(vk, vj);
                    where = MaxClearance.Where.self;
                    if (!entered_range) {
                      entered_range = true;
                    }
                  } else {
                    if (y > vk.upperBound) {
                      pos = this.subsume(vk, vj);
                      where = MaxClearance.Where.self;
                      this.updateBounds(vj, xc, direction);
                      if (!entered_range) {
                        entered_range = true;
                      }
                    } else if (y > vk.lowerBound) {
                      pos = vk;
                      where = MaxClearance.Where.lower;
                      this.updateBounds(vj, xc, direction);
                      if (!entered_range) {
                        entered_range = true;
                      }
                    } else if (entered_range) {
                      break;
                    }
                  }
                }
                vk = vk.lowerVertex;
              }
              if (entered_range) {
                this.connect(pos, vj, y, where);
                this.updateBounds(vj, xc, direction);
                vj.setSelected();
              }
            }
          }
        }
        y = 0;
        v = this.begin;
        while (y < this.main.height) {
          if (v) {
            if (y > v.upperBound && v.upperVertex) {
              v = v.upperVertex;
            }
            dist = this.distance(xc, y, v.x, v.y);
            if (!this.distData[xc + y * main.width] || this.distData[xc + y * main.width] > dist) {
              this.distData[xc + y * main.width] = dist;
            }
            val = Math.round(dist / this.maxdist * 255);
            this.mainContext.fillStyle = "rgba(255," + val + ",255,1)";
            this.mainContext.fillRect(xc, y, 1, 1);
          }
          y++;
        }
        v = this.begin;
        while (v) {
          this.updateBounds(v, xc, direction);
          this.mainContext.beginPath();
          this.mainContext.moveTo(xc, v.lowerBound);
          this.mainContext.lineTo(xc + 1, v.lowerBound);
          this.mainContext.moveTo(xc, v.upperBound);
          this.mainContext.lineTo(xc + 1, v.upperBound);
          this.mainContext.stroke();
          v = v.upperVertex;
        }
        _results.push(xc++);
      }
      return _results;
    };

    MaxClearance.Direction = {
      eastBound: 0,
      westBound: 1
    };

    MaxClearance.Where = {
      upper: 0,
      self: 1,
      lower: 2
    };

    MaxClearance.prototype.updateBounds = function(v, xc, direction) {
      if (v.upperVertex) {
        v.upperVertex.lowerBound = v.upperBound = v.getIntersectionY(v.upperVertex, xc, direction);
      }
      if (v.lowerVertex) {
        return v.lowerVertex.upperBound = v.lowerBound = v.getIntersectionY(v.lowerVertex, xc, direction);
      }
    };

    MaxClearance.prototype.connect = function(pos, v, y, where) {
      var lower, upper;
      upper = lower = void 0;
      switch (where) {
        case MaxClearance.Where.upper:
          if (pos.upperVertex) {
            pos.upperVertex.lowerVertex = v;
            v.upperVertex = pos.upperVertex;
          }
          upper = pos.upperVertex = v;
          lower = v.lowerVertex = pos;
          if (this.end === pos) {
            return this.end = v;
          }
          break;
        case MaxClearance.Where.self:
          if (pos.upperVertex) {
            lower = pos.upperVertex.lowerVertex = v;
            v.upperVertex = pos.upperVertex;
          }
          if (pos.lowerVertex) {
            upper = pos.lowerVertex.upperVertex = v;
            return v.lowerVertex = pos.lowerVertex;
          }
          break;
        case MaxClearance.Where.lower:
          if (pos.lowerVertex) {
            pos.lowerVertex.upperVertex = v;
            v.lowerVertex = pos.lowerVertex;
          }
          lower = pos.lowerVertex = v;
          upper = v.upperVertex = pos;
          if (this.begin === pos) {
            return this.begin = v;
          }
      }
    };

    MaxClearance.prototype.distance = function(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
    };

    MaxClearance.prototype.subsume = function(vk, vj) {
      vk.setSubsumed();
      if (vk.upperVertex) {
        vk.upperVertex.lowerVertex = vk.lowerVertex;
      }
      if (vk.lowerVertex) {
        vk.lowerVertex.upperVertex = vk.upperVertex;
      }
      vj.upperBound = vk.upperBound;
      vj.lowerBound = vk.lowerBound;
      vk.subsumedBy = vj;
      if (this.begin === vk) {
        this.begin = vj;
      }
      if (this.end === vk) {
        this.end = vj;
      }
      return vk;
    };

    MaxClearance.prototype.printStack = function() {
      var s, v;
      s = "";
      v = this.begin;
      while (v) {
        if (v && !v.isSubsumed()) {
          s += v.toString() + ", ";
        }
        v = v.upperVertex;
      }
      return console.log(s);
    };

    MaxClearance.prototype.distanceInfo = [];

    Vertex = (function() {

      function Vertex(x, y) {
        this.x = x;
        this.y = y;
        this.upperBound = 1.7976931348623157e10308;
        this.lowerBound = -1.7976931348623157e10308;
        this.upperVertex = void 0;
        this.lowerVertex = void 0;
      }

      Vertex.prototype.getIntersectionY = function(vertex, x, direction) {
        var atanRatio, midX, midY, y;
        if (direction === MaxClearance.Direction.eastBound) {
          midY = (vertex.y + this.y) / 2;
          if (vertex.x === this.x) {
            y = midY;
          } else {
            midX = (vertex.x + this.x) / 2;
            atanRatio = (vertex.y - this.y) / (vertex.x - this.x);
            y = midY - (x - midX) / atanRatio;
          }
          return y;
        } else if (direction === MaxClearance.Direction.westBound) {
          return alert('not implemented');
        }
      };

      Vertex.prototype.isSubsumed = function() {
        if (this.subsumed) {
          return true;
        } else {
          return false;
        }
      };

      Vertex.prototype.isSelected = function() {
        if (this.selected) {
          return true;
        } else {
          return false;
        }
      };

      Vertex.prototype.setSubsumed = function(v) {
        console.assert(this.selected);
        this.subsumedBy = v;
        return this.subsumed = true;
      };

      Vertex.prototype.setSelected = function() {
        return this.selected = true;
      };

      Vertex.prototype.toString = function() {
        return "(" + this.x + "," + this.y + ")";
      };

      return Vertex;

    })();

    return MaxClearance;

  })();

}).call(this);
