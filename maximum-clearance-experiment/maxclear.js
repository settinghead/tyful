// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var $img;
    $img = $("<img>", {
      src: "face.png"
    });
    return $img.load(function() {
      $('#source')[0].width = this.height;
      $('#source')[0].height = this.height;
      $('#source')[0].getContext('2d').drawImage(this, 0, 0, $('#source')[0].width, $('#source')[0].height);
      window.maxClearance = new MaxClearance($('#source')[0], $('#main')[0]);
      return window.maxClearance.compute();
    });
  });

  Array.prototype.nearestVertex = function(v) {
    return this[0];
  };

  window.MaxClearance = (function() {
    var Vertex;

    function MaxClearance(sourceCanvasEl, destCanvasEl) {
      this.source = sourceCanvasEl;
      this.main = destCanvasEl;
      this.sourceContext = this.source.getContext('2d');
      this.mainContext = this.main.getContext('2d');
      this.main.width = this.source.width;
      this.main.height = this.source.height;
      this.data = this.sourceContext.getImageData(0, 0, main.width, main.height).data;
      this.unit = 5;
    }

    MaxClearance.prototype.getAlpha = function(x, y) {
      var v;
      return v = this.data[(y * main.width + x) * 4 + 3];
    };

    MaxClearance.prototype.compute = function() {
      var d;
      this.distData = new Uint32Array(this.main.width * this.main.height);
      this.maxdist = 0;
      d = 0;
      while (d < this.main.width * this.main.height) {
        this.distData[d] = this.maxdist;
        d++;
      }
      this.sweep(MaxClearance.Direction.eastBound);
      this.sweep(MaxClearance.Direction.westBound);
      this.printBoundaries();
      return this.printGradientMap();
    };

    MaxClearance.prototype.sweep = function(direction) {
      var alpha, dist, entered_range, i, in_range, minBorderDist, n, newVertices, nn, pos, v, vj, vk, where, xc, y, _i, _len, _ref, _results;
      n = main.width;
      this.A = [];
      this.partitions = [1.7976931348623157e10308, -1.7976931348623157e10308];
      i = 0;
      xc = direction > 0 ? 0 : n - 1;
      nn = direction > 0 ? n : 0;
      _results = [];
      while (xc * direction < nn) {
        y = 0;
        newVertices = [];
        while (y < n) {
          alpha = this.getAlpha(xc, y);
          if (alpha === 0) {
            v = new Vertex(xc, y);
            v.alpha = alpha;
            this.A[y] = v;
            newVertices.push(v);
          }
          y += this.unit;
        }
        if (xc % this.unit === 0) {
          _ref = this.A;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vj = _ref[_i];
            if (vj && !vj.isSubsumed() && !vj.isSelected()) {
              if (!this.begin) {
                this.begin = this.end = vj;
                vj.setSelected();
              } else {
                in_range = true;
                entered_range = false;
                pos = void 0;
                where = void 0;
                vk = this.end;
                while (vk) {
                  if (!vk.isSubsumed()) {
                    y = vj.getIntersectionY(vk, xc, direction);
                    if (vj.y > vk.y) {
                      if (y < vk.lowerBound) {
                        pos = this.subsume(vk, vj);
                        where = MaxClearance.Where.self;
                        this.updateBounds(vj, xc, direction);
                        if (!entered_range) {
                          entered_range = true;
                        }
                      } else if (y < vk.upperBound) {
                        pos = vk;
                        where = MaxClearance.Where.upper;
                        this.updateBounds(vj, xc, direction);
                        if (!entered_range) {
                          entered_range = true;
                        }
                      } else if (entered_range) {
                        break;
                      }
                    } else if (vj.y === vk.y) {
                      pos = this.subsume(vk, vj);
                      where = MaxClearance.Where.self;
                      if (!entered_range) {
                        entered_range = true;
                      }
                    } else {
                      if (y > vk.upperBound) {
                        pos = this.subsume(vk, vj);
                        where = MaxClearance.Where.self;
                        this.updateBounds(vj, xc, direction);
                        if (!entered_range) {
                          entered_range = true;
                        }
                      } else if (y > vk.lowerBound) {
                        pos = vk;
                        where = MaxClearance.Where.lower;
                        this.updateBounds(vj, xc, direction);
                        if (!entered_range) {
                          entered_range = true;
                        }
                      } else if (entered_range) {
                        break;
                      }
                    }
                  }
                  vk = vk.lowerVertex;
                }
                if (entered_range) {
                  this.connect(pos, vj, y, where);
                  this.updateBounds(vj, xc, direction);
                  vj.setSelected();
                }
              }
            }
          }
        }
        y = 0;
        v = this.begin;
        while (y < this.main.height) {
          if (v) {
            if (y > v.upperBound && v.upperVertex) {
              v = v.upperVertex;
            }
            dist = this.distance(xc, y, v.x, v.y);
            minBorderDist = this.getMinBorderDistance(xc, y);
            if (minBorderDist < dist) {
              dist = minBorderDist;
            }
            if (dist > this.maxdist) {
              this.maxdist = dist;
            }
            if (!this.distData[xc + y * main.width] || this.distData[xc + y * main.width] > dist) {
              this.distData[xc + y * main.width] = dist;
            }
          }
          y++;
        }
        _results.push(xc += direction);
      }
      return _results;
    };

    MaxClearance.Direction = {
      eastBound: 1,
      westBound: -1
    };

    MaxClearance.Where = {
      upper: 0,
      self: 1,
      lower: 2
    };

    MaxClearance.prototype.getMinBorderDistance = function(x, y) {
      var minXBorderDist, minYBorderDist;
      if (x > this.main.width / 2) {
        minXBorderDist = this.main.width - x;
      } else {
        minXBorderDist = x;
      }
      if (y > this.main.height / 2) {
        minYBorderDist = this.main.height - y;
      } else {
        minYBorderDist = y;
      }
      if (minXBorderDist < minYBorderDist) {
        return minXBorderDist;
      } else {
        return minYBorderDist;
      }
    };

    MaxClearance.prototype.printBoundaries = function() {
      var xc, _results;
      xc = 0;
      _results = [];
      while (xc < main.width) {
        _results.push(xc++);
      }
      return _results;
    };

    MaxClearance.prototype.printGradientMap = function() {
      var val, xc, y, _results;
      xc = 0;
      _results = [];
      while (xc < main.width) {
        y = 0;
        while (y < this.main.height) {
          val = Math.round(this.distData[xc + y * main.width] / this.maxdist * 255);
          this.mainContext.fillStyle = "rgba(255," + val + ",255,1)";
          this.mainContext.fillRect(xc, y, 1, 1);
          y++;
        }
        _results.push(xc++);
      }
      return _results;
    };

    MaxClearance.prototype.updateBounds = function(v, xc, direction) {
      if (v.upperVertex) {
        v.upperVertex.lowerBound = v.upperBound = v.getIntersectionY(v.upperVertex, xc, direction);
      }
      if (v.lowerVertex) {
        return v.lowerVertex.upperBound = v.lowerBound = v.getIntersectionY(v.lowerVertex, xc, direction);
      }
    };

    MaxClearance.prototype.connect = function(pos, v, y, where) {
      var lower, upper;
      upper = lower = void 0;
      switch (where) {
        case MaxClearance.Where.upper:
          if (pos.upperVertex) {
            pos.upperVertex.lowerVertex = v;
            v.upperVertex = pos.upperVertex;
          }
          upper = pos.upperVertex = v;
          lower = v.lowerVertex = pos;
          if (this.end === pos) {
            return this.end = v;
          }
          break;
        case MaxClearance.Where.self:
          if (pos.upperVertex) {
            lower = pos.upperVertex.lowerVertex = v;
            v.upperVertex = pos.upperVertex;
          }
          if (pos.lowerVertex) {
            upper = pos.lowerVertex.upperVertex = v;
            return v.lowerVertex = pos.lowerVertex;
          }
          break;
        case MaxClearance.Where.lower:
          if (pos.lowerVertex) {
            pos.lowerVertex.upperVertex = v;
            v.lowerVertex = pos.lowerVertex;
          }
          lower = pos.lowerVertex = v;
          upper = v.upperVertex = pos;
          if (this.begin === pos) {
            return this.begin = v;
          }
      }
    };

    MaxClearance.prototype.distance = function(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
    };

    MaxClearance.prototype.subsume = function(vk, vj) {
      vk.setSubsumed();
      if (vk.upperVertex) {
        vk.upperVertex.lowerVertex = vk.lowerVertex;
      }
      if (vk.lowerVertex) {
        vk.lowerVertex.upperVertex = vk.upperVertex;
      }
      vj.upperBound = vk.upperBound;
      vj.lowerBound = vk.lowerBound;
      vk.subsumedBy = vj;
      if (this.begin === vk) {
        this.begin = vj;
      }
      if (this.end === vk) {
        this.end = vj;
      }
      return vk;
    };

    MaxClearance.prototype.printStack = function() {
      var s, v;
      s = "";
      v = this.begin;
      while (v) {
        if (v && !v.isSubsumed()) {
          s += v.toString() + ", ";
        }
        v = v.upperVertex;
      }
      return console.log(s);
    };

    MaxClearance.prototype.distanceInfo = [];

    Vertex = (function() {

      function Vertex(x, y) {
        this.x = x;
        this.y = y;
        this.upperBound = 1.7976931348623157e10308;
        this.lowerBound = -1.7976931348623157e10308;
        this.upperVertex = void 0;
        this.lowerVertex = void 0;
      }

      Vertex.prototype.getIntersectionY = function(vertex, x, direction) {
        var atanRatio, midX, midY, y;
        midY = (vertex.y + this.y) / 2;
        if (vertex.x === this.x) {
          y = midY;
        } else {
          midX = (vertex.x + this.x) / 2;
          atanRatio = (vertex.y - this.y) / (vertex.x - this.x);
          y = midY - (x - midX) / atanRatio;
        }
        return y;
      };

      Vertex.prototype.isSubsumed = function() {
        if (this.subsumed) {
          return true;
        } else {
          return false;
        }
      };

      Vertex.prototype.isSelected = function() {
        if (this.selected) {
          return true;
        } else {
          return false;
        }
      };

      Vertex.prototype.setSubsumed = function(v) {
        console.assert(this.selected);
        this.subsumedBy = v;
        return this.subsumed = true;
      };

      Vertex.prototype.setSelected = function() {
        return this.selected = true;
      };

      Vertex.prototype.toString = function() {
        return "(" + this.x + "," + this.y + ")";
      };

      return Vertex;

    })();

    return MaxClearance;

  })();

}).call(this);
