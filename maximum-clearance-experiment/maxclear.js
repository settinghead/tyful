// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var $img;
    $img = $("<img>", {
      src: "pbs.png"
    });
    return $img.load(function() {
      $('#source')[0].width = this.height;
      $('#source')[0].height = this.height;
      $('#source')[0].getContext('2d').drawImage(this, 0, 0, $('#source')[0].width, $('#source')[0].height);
      return window.maxClearance = new MaxClearance($('#source')[0], $('#main')[0]);
    });
  });

  window.MaxClearance = (function() {

    function MaxClearance(sourceCanvasEl, destCanvasEl) {
      this.source = sourceCanvasEl;
      this.main = destCanvasEl;
      this.sourceContext = this.source.getContext('2d');
      this.mainContext = this.main.getContext('2d');
      this.main.width = this.source.width;
      this.main.height = this.source.height;
      this.data = this.sourceContext.getImageData(0, 0, main.width, main.height).data;
    }

    MaxClearance.prototype.getAlpha = function(x, y) {
      return this.data[(y * main.width + x) * 4 + 3];
    };

    MaxClearance.prototype.compute = function() {
      var dist, n, newVertices, v, vj, vk, x, y, _i, _len, _results;
      n = main.width;
      this.A = [];
      this.partitions = [1.7976931348623157e10308, -1.7976931348623157e10308];
      this.stack = [];
      this.distData = new Uint32Array(this.main.width * this.main.height);
      this.maxdist = Math.sqrt(Math.pow(this.main.width, 2) + Math.pow(this.main.height, 2));
      x = 0;
      _results = [];
      while (x < n) {
        y = 0;
        newVertices = [];
        while (y < n) {
          if (this.getAlpha(x, y) > 0) {
            v = new Vertice(x, y);
            A[y] = v;
            newVertices.push(v);
          }
          y++;
        }
        for (_i = 0, _len = A.length; _i < _len; _i++) {
          vj = A[_i];
          if (vj && !vj.isSubsumed()) {
            if (!this.stack.length) {
              this.stack.push(vj);
              vj.upperBound = 1.7976931348623157e10308;
              vj.loweBound = -1.7976931348623157e10308;
            } else {
              while (true) {
                vk = this.stack[0];
                y = vj.getIntersectionY(vk, x, MaxClearance.Direction.eastBound);
                if (y < vk.lowerBound) {
                  this.stack.pop();
                  vk.setSubsumed();
                } else {
                  vj.upperBound = 1.7976931348623157e10308;
                  vk.upperBound = vj.lowerBound = y;
                  this.stack.push(vj);
                  break;
                }
              }
            }
          }
        }
        y = 0;
        while (y < n) {
          v = stack.nearestVertix(y);
          dist = distance(x, y, v.x, v.y);
          distData[x + y * main.width] = dist;
          this.mainConext.fillStyle = "rgb(255,255," + (dist / this.maxdist) + ")";
          this.mainContext.rect(x, y, 1, 1);
          y++;
        }
        _results.push(x++);
      }
      return _results;
    };

    MaxClearance.Direction = {
      eastBound: 0,
      westBound: 1
    };

    return MaxClearance;

  })();

  Array.prototype.nearestVertex = function(v) {};

  window.Vertex = (function() {

    function Vertex(x, y) {
      this.x = x;
      this.y = y;
    }

    Vertex.prototype.getIntersectionY = function(vertex, x, direction) {
      var atanRatio, midX, midY, y;
      if (direction === MaxClearance.Direction.eastBound) {
        midX = (vertex.x + this.x) / 2;
        midY = (vertex.y + this.y) / 2;
        atanRatio = (vertex.y - this.y) / (vetex.x - this.x);
        y = (midX - x) * atanRatio + midY;
        return y;
      } else if (direction === MaxClearance.Direction.westBound) {
        return alert('not implemented');
      }
    };

    Vertex.prototype.isSubsumed = function() {
      if (this.subsumed) {
        return true;
      } else {
        return false;
      }
    };

    Vertex.prototype.setSubsumed = function() {
      return this.subsumed = true;
    };

    return Vertex;

  })();

}).call(this);
